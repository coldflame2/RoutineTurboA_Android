
// Content from MainActivity.kt
package com.app.routineturboa



class MainActivity : ComponentActivity() {
    private val tag = "MainActivity"
    private lateinit var isNotificationPermissionGiven: MutableState<Boolean>
    private lateinit var showPermissionDialog: MutableState<Boolean>
    private lateinit var reminderManager: ReminderManager

    @RequiresApi(Build.VERSION_CODES.S)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Log.d(tag, "onCreate for MainActivity")

        // Set to true to make system windows visible
        WindowCompat.setDecorFitsSystemWindows(window, true)
        reminderManager = ReminderManager(this)
        // Initialize the state variables
        isNotificationPermissionGiven = mutableStateOf(NotificationPermissionHandler.isNotificationPermissionGiven(this))
        showPermissionDialog = mutableStateOf(!isNotificationPermissionGiven.value)

        // Register the ActivityResultLauncher
        NotificationPermissionHandler.initialize(this, isNotificationPermissionGiven)

        setContent {
            RoutineTurboATheme {
                window.statusBarColor = MaterialTheme.colorScheme.primary.toArgb()
                window.navigationBarColor = MaterialTheme.colorScheme.primary.toArgb()

                MainScreen(reminderManager = reminderManager)

                if (showPermissionDialog.value) {
                    AlertDialog(
                        title = { Text("Notification Permission") },
                        text = {
                            Text (text = "This app needs notification permission to send you reminders." +
                                    "Would you like to grant this permission?")
                        },
                        onDismissRequest = { showPermissionDialog.value = false },
                        dismissButton = {
                            Button(onClick = { showPermissionDialog.value = false }) {
                                Text("Not Now")
                            }
                        },
                        confirmButton = {
                            Button(onClick = {
                                showPermissionDialog.value = false
                                NotificationPermissionHandler.requestNotificationPermission()
                            }) {
                                Text("Grant Permission")
                            }
                        }
                    )
                }
            }
        }
    }
}


// Content from RoutineTurboApp.kt
package com.app.routineturboa


class RoutineTurboApp : Application() {
    private val applicationScope = CoroutineScope(SupervisorJob() + Dispatchers.Main)
    lateinit var msalAuthManager: MsalAuthManager

    companion object {
        lateinit var instance: RoutineTurboApp
            private set
    }

    override fun onCreate() {
        super.onCreate()

        Log.d("MyApplication", "     ***** STARTING APPLICATION ****** ")

        instance = this

        msalAuthManager = MsalAuthManager.getInstance(this)

        applicationScope.launch {
            Log.d("MyApplication", "Calling MsalAuthManager.initialize from MyApplication")
            msalAuthManager.initialize()
        }

        createNotificationChannel()
    }

    private fun createNotificationChannel() {
        val channelId = "tasks_channel_id"
        val channelName = "Tasks Reminders"
        val importance = NotificationManager.IMPORTANCE_HIGH

        val channel = NotificationChannel(channelId, channelName, importance)
        channel.description = "Channel for tasks reminders"

        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        notificationManager.createNotificationChannel(channel)
    }
}

// Content from RoutineDatabase.kt
package com.app.routineturboa.data.local


@Database(entities = [TaskEntity::class], version = 2, exportSchema = false)
@TypeConverters(Converters::class)
abstract class RoutineDatabase : RoomDatabase() {
    abstract fun taskDao(): TaskDao


    companion object {
        @Volatile
        private var INSTANCE: RoutineDatabase? = null

        private val MIGRATION_1_2 = object : Migration(1, 2) {
            override fun migrate(database: SupportSQLiteDatabase) {
                // Adding the new column to the existing table
                database.execSQL("ALTER TABLE tasks_table ADD COLUMN mainTaskId INTEGER DEFAULT NULL")
            }
        }

        fun getDatabase(context: Context): RoutineDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    RoutineDatabase::class.java,
                    context.getString(R.string.database_name)
                )
                    .addMigrations(MIGRATION_1_2)
                    .build()
                INSTANCE = instance
                instance
            }
        }
    }
}

// Content from RoutineRepository.kt
package com.app.routineturboa.data.local



class RoutineRepository(val context: Context) {
    val tag = "RoutineRepository"
    private var routineDatabase = RoutineDatabase.getDatabase(context)
    private var taskDao: TaskDao = routineDatabase.taskDao()

    fun getAllTasks(): Flow<List<TaskEntity>> = taskDao.getAllTasks()

    // Function to get tasks by type
    fun getTasksByType(type: String): Flow<List<TaskEntity>> {
        return taskDao.getTasksByType(type)
    }

    suspend fun insertTask(task: TaskEntity): Long {
        Log.d(tag, "Inserting task with ID: ${task.id}. Task Name: ${task.name}")

        // Ensure the first and last tasks are correctly identified
        val firstTask = taskDao.getFirstTask()
        val lastTask = taskDao.getLastTask()

        if (firstTask == null || lastTask == null) {
            Log.e(tag, "First or last task not found. Please ensure default tasks are initialized.")
            throw IllegalStateException("First or last task not found.")
        }

        // Insert the new task with its correct properties (id will be auto-generated)
        return taskDao.insertTask(task)
    }

    suspend fun updateTask(task: TaskEntity) {
        Log.d(tag, "Updating task: ${task.name} and id:${task.id}")
        taskDao.updateTask(task)
    }

    suspend fun <T> runAsTransaction(block: suspend () -> T): T {
        return withContext(Dispatchers.IO) {
            routineDatabase.withTransaction {
                block()
            }
        }
    }

    private suspend fun insertDefaultTasks(defaultTask: TaskEntity): Long {
        Log.d(tag,"Inserting default task.")
        return taskDao.insertTask(defaultTask)
    }

    suspend fun updateTasksWithNewPositions(tasks: List<TaskEntity>) {
        taskDao.updateTasksWithNewPositions(tasks)
    }

    suspend fun deleteTask(task: TaskEntity) = taskDao.deleteTask(task)

    suspend fun getTaskById(taskId: Int): TaskEntity? = taskDao.getTaskById(taskId)

    fun closeDatabase() {
        routineDatabase.close()
    }

    fun reopenDatabase() {
        routineDatabase = RoutineDatabase.getDatabase(context)
        taskDao = routineDatabase.taskDao()
    }

    suspend fun initializeDefaultTasks() {
        val tasks = taskDao.getAllTasks().first()

        if (tasks.isEmpty()) {
            val firstTask = TaskEntity(
                id = -1,
                position = 1,
                name = "Start of Day",
                notes = "",
                duration = 359,
                startTime = strToDateTime("00:01 AM"),
                endTime = strToDateTime("06:00 AM"),
                reminder = strToDateTime("06:00 AM"),
                type = "default"
            )

            insertDefaultTasks(firstTask)

            val lastTask = TaskEntity(
                id = -2,
                position = Int.MAX_VALUE,
                name = "End of Day",
                notes = "",
                duration = 1079,
                startTime = strToDateTime("06:00 AM"),
                endTime = strToDateTime("11:59 PM"),
                reminder = strToDateTime("06:00 AM"),
                type = "default",
            )

            insertDefaultTasks(lastTask)
        }
    }

    suspend fun initializeDemoTasks() {
        val tasks = taskDao.getAllTasks().first()

        if (tasks.isNotEmpty()) {
            insertTask(demoTaskTwo)
            insertTask(demoTaskThree)
            insertTask(demoTaskFour)
            insertTask(demoTaskFive)
            insertTask(demoTaskSix)
            insertTask(demoTaskSeven)
            insertTask(demoTaskEight)
            insertTask(demoTaskNine)
            insertTask(demoTaskTen)
            insertTask(demoTaskEleven)
            insertTask(demoTaskTwelve)
            insertTask(demoTaskThirteen)
            insertTask(demoTaskFourteen)
            insertTask(demoTaskFifteen)
            insertTask(demoTaskSixteen)
            insertTask(demoTaskSeventeen)
            insertTask(demoTaskEighteen)
            insertTask(demoTaskNineteen)
            insertTask(demoTaskTwenty)
            insertTask(demoTaskTwentyOne)
            insertTask(demoTaskTwentyTwo)
        }
    }
}


// Content from TaskDao.kt
package com.app.routineturboa.data.local


const val tag = "TaskDao"

@Dao
interface TaskDao {

    @Query("SELECT * FROM tasks_table ORDER BY position ASC")
    fun getAllTasks(): Flow<List<TaskEntity>>

    // Query to get tasks by type
    @Query("SELECT * FROM tasks_table WHERE type = :type")
    fun getTasksByType(type: String): Flow<List<TaskEntity>>

    @Insert(onConflict = OnConflictStrategy.ABORT)
    suspend fun insertTask(task: TaskEntity): Long

    @Update
    suspend fun updateTask(task: TaskEntity)

    @Transaction
    suspend fun updateTasksWithNewPositions(tasks: List<TaskEntity>) {
        tasks.forEach { task ->
            Log.d(tag, "Updating task '${task.name}'. task ID: ${task.id}, position: ${task.position}" )
            updateTaskPosition(task.id, task.position)
        }
    }

    @Transaction
    suspend fun updateTasksWithNewIds(tasks: List<TaskEntity>) {
        tasks.forEach { task ->
            Log.d(tag, "Updating task '${task.name}'. task ID: ${task.id}" )
            updateTaskId(task.id)
        }
    }

    @Query("UPDATE tasks_table SET id = :newId")
    suspend fun updateTaskId(newId: Int)

    @Query("UPDATE tasks_table SET position = :newPosition WHERE id = :taskId")
    suspend fun updateTaskPosition(taskId: Int, newPosition: Int)

    @Update
    suspend fun updateAllTasks(tasks: List<TaskEntity>)

    @Delete
    suspend fun deleteTask(task: TaskEntity)

    @Query("SELECT * FROM tasks_table WHERE id = :taskId")
    suspend fun getTaskById(taskId: Int): TaskEntity?

    @Query("SELECT * FROM tasks_table WHERE id = (SELECT MIN(id) FROM tasks_table)")
    suspend fun getFirstTask(): TaskEntity?

    @Query("SELECT * FROM tasks_table WHERE id = (SELECT MAX(id) FROM tasks_table)")
    suspend fun getLastTask(): TaskEntity?
}

// Content from TaskEntity.kt
package com.app.routineturboa.data.local


@Entity(tableName = "tasks_table")
@TypeConverters(Converters::class)
data class TaskEntity(
    @PrimaryKey(autoGenerate = true) val id: Int = 0,
    val name: String,
    val notes: String,
    val duration: Int,
    val startTime: LocalDateTime,
    val endTime: LocalDateTime,
    val reminder: LocalDateTime,
    val type: String,
    val position: Int,
    val mainTaskId: Int? = null // This is the foreign key to link to another task
)


// Content from downloadFromOneDrive.kt
package com.app.routineturboa.data.onedrive


suspend fun downloadFromOneDrive(authResult: IAuthenticationResult, context: Context, tasksViewModel: TasksViewModel) {
    val tag = "downloadFromOneDrive"
    Log.d(tag, "Downloading from OneDrive")
    val authProvider = OneDriveManager.MsalAuthProvider(authResult)
    val oneDriveManager = OneDriveManager(authProvider)

    val files = withContext(Dispatchers.IO) {
        oneDriveManager.listFiles()
    }

    val routineTurboDir = files.find { it.name == "RoutineTurbo" && it.folder != null }

    routineTurboDir?.let { dir ->
        val dirFiles = dir.id?.let { dirId ->
            withContext(Dispatchers.IO) {
                oneDriveManager.listFiles(dirId)
            }
        }

        val dbFile = dirFiles?.find { it.name == "RoutineTurbo.db" }

        dbFile?.let { driveItem ->
            driveItem.id?.let { driveItemId ->
                val localDbFile = context.getDatabasePath("RoutineTurbo.db")
                withContext(Dispatchers.IO) {
                    oneDriveManager.downloadFile(driveItemId, localDbFile)
                }
            }
        }
    }

    tasksViewModel.tasks

    Log.d(tag, "Finished downloading from OneDrive")
}

suspend fun uploadToOneDrive(authResult: IAuthenticationResult, context: Context) {
    val tag = "uploadToOneDrive"
    Log.d(tag, "Uploading to OneDrive")
    val authProvider = OneDriveManager.MsalAuthProvider(authResult)
    val oneDriveManager = OneDriveManager(authProvider)

    val files = withContext(Dispatchers.IO) {
        oneDriveManager.listFiles()
    }

    var routineTurboDir = files.find { it.name == "RoutineTurbo" && it.folder != null }

    if (routineTurboDir == null) {
        // Create RoutineTurbo folder if it doesn't exist
        routineTurboDir = withContext(Dispatchers.IO) {
            oneDriveManager.createFolder("RoutineTurbo")
        }
    }

    if (routineTurboDir != null) {
        routineTurboDir.id?.let { dirId ->
            val localDbFile = context.getDatabasePath("RoutineTurbo.db")
            withContext(Dispatchers.IO) {
                oneDriveManager.uploadFile(dirId, "RoutineTurbo.db", localDbFile)
            }
        }
    }

    Log.d(tag, "Finished uploading to OneDrive")
}

// Content from MsalAuthManager.kt
package com.app.routineturboa.data.onedrive



class MsalAuthManager(context: Context) {
    var tag = "MsalAuthManager"

    private val _isInitialized = MutableStateFlow(false)
    val isInitialized: StateFlow<Boolean> get() = _isInitialized

    private val appContext = context.applicationContext
    var singleAccountApp: ISingleAccountPublicClientApplication? = null
    var currentAccount: IAccount? = null

    init {
        Log.d(tag, "init: Creating Msal Application.")
        createMsalApplication()
    }

    suspend fun initialize() {
        Log.d(tag, "MsalAuthManager initialize function...")

    }

    private fun onInitialized(callback: () -> Unit) {
        Log.d(tag, "MsalAuthManager onInitialized")
    }

    private fun createMsalApplication() {
        Log.d(tag, "Creating MSAL single account application")

        PublicClientApplication.createSingleAccountPublicClientApplication(
            appContext,
            R.raw.auth_config_single_account,
            getMsalClientListener()
        )
    }

    /**
     * This function provides a listener that handles the success or failure of the MSAL client creation.
     */
    private fun getMsalClientListener(): IPublicClientApplication.ISingleAccountApplicationCreatedListener {
        Log.d(tag, "Creating MSAL client listener")

        return object : IPublicClientApplication.ISingleAccountApplicationCreatedListener {
            override fun onCreated(msalApplication: ISingleAccountPublicClientApplication) {
                Log.d(tag, "MSAL client created successfully")
                singleAccountApp = msalApplication
                _isInitialized.value = true
            }

            override fun onError(exception: MsalException) {
                Log.e(tag, "MSAL client creation error: ${exception.message}")
            }
        }
    }

    /**
     * This is a suspending function that wraps getCurrentAccountAsync in a coroutine.
     */
    private suspend fun getCurrentAccountSuspend(): IAccount? = suspendCoroutine { continuation ->
        Log.d(tag, "Getting current account using suspend function.")

        singleAccountApp?.getCurrentAccountAsync(
            object : ISingleAccountPublicClientApplication.CurrentAccountCallback {
                override fun onAccountLoaded(activeAccount: IAccount?) {
                    Log.d(tag, "Current account loaded: ${activeAccount?.username}")
                    continuation.resume(activeAccount)
                }

                override fun onAccountChanged(priorAccount: IAccount?, currentAccount: IAccount?) {
                    Log.d(tag, "Account changed: ${currentAccount?.username}")
                    continuation.resume(currentAccount)
                }

                override fun onError(exception: MsalException) {
                    Log.e(tag, "Error getting current account", exception)
                    continuation.resumeWithException(exception)
                }
            }
        )
    }

    fun getCurrentAccount(callback: ((IAccount?) -> Unit)?) {
        Log.d(tag, "Getting current account...")

        singleAccountApp?.getCurrentAccountAsync(
            object : ISingleAccountPublicClientApplication.CurrentAccountCallback {
                override fun onAccountLoaded(activeAccount: IAccount?) {
                    Log.d(tag, "getCurrentAccount: onAccountLoaded-currentAccount: ${activeAccount?.username}")
                    callback?.invoke(activeAccount)
                    currentAccount = activeAccount
                }

                override fun onAccountChanged(priorAccount: IAccount?, currentAccount: IAccount?) {
                    Log.d(tag, "getCurrentAccount: onAccountChanged-currentAccount: ${currentAccount?.username} and priorAccount: ${priorAccount?.username}")
                    callback?.invoke(currentAccount)

                }

                override fun onError(exception: MsalException) {
                    Log.e(tag, "Error getting current account", exception)
                    callback?.invoke(null)

                }
            }
        )
    }

    private fun checkCurrentAccount() {
        Log.d(tag, "Checking current account...")

        singleAccountApp?.getCurrentAccountAsync(
            object : ISingleAccountPublicClientApplication.CurrentAccountCallback {
                override fun onAccountLoaded(activeAccount: IAccount?) {
                    if (activeAccount != null) {
                        Log.d(tag, "Current Account Found: ${activeAccount.username}")
                        currentAccount = activeAccount
                    } else {
                        Log.d(tag, "No account is signed in.")
                    }
                }

                override fun onAccountChanged(priorAccount: IAccount?, currentAccount: IAccount?) {
                    Log.e(tag, "Account changed: ${currentAccount?.username}")
                    this@MsalAuthManager.currentAccount = currentAccount
                }

                override fun onError(exception: MsalException) {
                    Log.e(tag, "Error loading current account: ${exception.message}")
                }
            }
        )
    }

    suspend fun signIn(activity: Activity): IAuthenticationResult {
        return suspendCoroutine { continuation ->
            fun signInAttempt() {
                val parameters = AcquireTokenParameters.Builder()
                    .startAuthorizationFromActivity(activity)
                    .withScopes(listOf("User.Read", "Files.Read"))
                    .withCallback(object : AuthenticationCallback {
                        override fun onSuccess(result: IAuthenticationResult) {
                            continuation.resume(result)
                        }

                        override fun onError(exception: MsalException) {
                            if (exception.errorCode == "current_account_mismatch") {
                                Log.e("MsalAuthManager", "Current account mismatch. Attempting sign out.")
                                // If there's a mismatch, sign out and try again
                                signOut {
                                    signInAttempt()
                                }
                            } else {
                                continuation.resumeWithException(exception)
                            }
                        }

                        override fun onCancel() {
                            continuation.resumeWithException(Exception("Sign-in canceled"))
                        }
                    })
                    .build()

                singleAccountApp?.acquireToken(parameters)
            }

            signInAttempt()
        }
    }

    fun signOut(onComplete: () -> Unit) {
        singleAccountApp?.signOut(object : ISingleAccountPublicClientApplication.SignOutCallback {
            override fun onSignOut() {
                Log.d(tag, "Signed out successfully")
                onComplete()
            }

            override fun onError(exception: MsalException) {
                Log.e(tag, "Sign out error: ${exception.message}")
                onComplete()
            }
        })
    }

    // New suspend function that wraps the regular signOut
    suspend fun signOutSuspend(): Boolean = suspendCoroutine { continuation ->
        signOut {
            continuation.resume(true)
        }
    }

    /**
     * This function performs a silent token acquisition. If a valid access token is found in the cache, it is returned.
     * Otherwise, it attempts to use a refresh token to obtain a new access token.
     *
     * @param account The account for which the token is being acquired.
     * @return The access token, or null if an error occurs.
     */
    private suspend fun acquireTokenSilently(account: IAccount): String? = suspendCoroutine { continuation ->
        Log.d(tag, "acquiring tokens silently...")
        val parameters = AcquireTokenSilentParameters.Builder()
            .forAccount(account)
            .fromAuthority(account.authority)
            .withScopes(listOf("User.Read", "Files.Read"))
            .withCallback(object : AuthenticationCallback {
                override fun onSuccess(result: IAuthenticationResult) {
                    continuation.resume(result.accessToken)
                }

                override fun onError(exception: MsalException) {
                    Log.e(tag, "Error acquiring token silently $exception. LocalAccountID: $account")
                    continuation.resumeWithException(exception)
                }

                override fun onCancel() {
                    Log.e(tag, "Token acquisition cancelled")
                    continuation.resumeWithException(Exception("Token acquisition cancelled"))
                }
            })
            .build()

        singleAccountApp?.acquireTokenSilentAsync(parameters)
    }


    private fun saveImageToFile(byteArray: ByteArray): String {
        val bitmap = BitmapFactory.decodeByteArray(byteArray, 0, byteArray.size)
        val file = File(appContext.cacheDir, "profile_image.png")
        FileOutputStream(file).use { out ->
            bitmap.compress(Bitmap.CompressFormat.PNG, 100, out)
        }
        return file.absolutePath
    }

    suspend fun getProfileImageUrl(): String? {
        Log.d(tag, "Getting profile image URL...")
        val account = currentAccount ?: return null

        return withContext(Dispatchers.IO) {
            try {
                val token = acquireTokenSilently(account) ?: return@withContext null
                val client = OkHttpClient()
                val request = Request.Builder()
                    .url("https://graph.microsoft.com/v1.0/me/photo/\$value")
                    .addHeader("Authorization", "Bearer $token")
                    .build()

                val response = client.newCall(request).execute()
                if (response.isSuccessful) {
                    val byteArray = response.body?.bytes()
                    byteArray?.let {
                        val localProfileImagePath = saveImageToFile(it)
                        Log.d(tag, "Local profile image path: $localProfileImagePath")
                        localProfileImagePath  // this is the value that the function returns
                    }
                } else {
                    Log.e(tag, "Failed to fetch profile image, response code: ${response.code}")
                    null
                }

            } catch (e: Exception) {
                Log.e(tag, "Error fetching profile image: ${e.message}")
                e.printStackTrace()
                null
            }
        }
    }

    companion object {
        @Volatile
        private var INSTANCE: MsalAuthManager? = null

        // Returns the single instance of this class, creating it if necessary.
        fun getInstance(context: Context): MsalAuthManager =
            INSTANCE ?: synchronized(this) {
                INSTANCE ?: MsalAuthManager(context).also { INSTANCE = it }
            }
    }

}


// Content from OneDriveManager.kt
package com.app.routineturboa.data.onedrive


class OneDriveManager(private val authProvider: IAuthenticationProvider) {

    private val graphClient = GraphServiceClient.builder()
        .authenticationProvider(authProvider)
        .buildClient()

    fun listFiles(driveItemId: String? = null): List<DriveItem> {
        Log.d("OneDriveManager", "Listing files for drive item ID: $driveItemId")
        val request = if (driveItemId == null) {
            graphClient.me().drive().root().children().buildRequest()
        } else {
            graphClient.me().drive().items(driveItemId).children().buildRequest()
        }

        val files = request.get()?.currentPage ?: emptyList()
        Log.d("OneDriveManager", "Found ${files.size} files")
        return files
    }

    fun downloadFile(driveItemId: String, destinationFile: File): Boolean {
        Log.d("OneDriveManager", "Downloading file with ID: $driveItemId to ${destinationFile.absolutePath}")
        val request = graphClient.me().drive().items(driveItemId).content().buildRequest()

        return try {
            val inputStream = request.get()
            if (inputStream != null) {
                FileOutputStream(destinationFile).use { outputStream ->
                    inputStream.copyTo(outputStream)
                }
                Log.d("OneDriveManager", "File downloaded successfully")
                true
            } else {
                Log.e("OneDriveManager", "Failed to download file: input stream is null")
                false
            }
        } catch (e: Exception) {
            Log.e("OneDriveManager", "Error downloading file: ${e.message}")
            e.printStackTrace()
            false
        }
    }

    fun createFolder(folderName: String): DriveItem? {
        Log.d("OneDriveManager", "Creating folder with name: $folderName")

        val driveItem = DriveItem()
        driveItem.name = folderName
        driveItem.folder = com.microsoft.graph.models.Folder()

        return try {
            val result = graphClient.me().drive().root().children()
                .buildRequest()
                .post(driveItem)
            Log.d("OneDriveManager", "Folder created successfully with ID: ${result.id}")
            result
        } catch (e: Exception) {
            Log.e("OneDriveManager", "Error creating folder: ${e.message}")
            e.printStackTrace()
            null
        }
    }

    fun uploadFile(parentFolderId: String, fileName: String, file: File): DriveItem? {
        Log.d("OneDriveManager", "Uploading file: ${file.absolutePath} to folder: $parentFolderId")

        return try {
            val fileContent = file.readBytes()
            val result = graphClient.me().drive().items(parentFolderId).children(fileName).content()
                .buildRequest()
                .put(fileContent)
            if (result != null) {
                Log.d("OneDriveManager", "File uploaded successfully with ID: ${result.id}")
            }
            result
        } catch (e: Exception) {
            Log.e("OneDriveManager", "Error uploading file: ${e.message}")
            e.printStackTrace()
            null
        }
    }

    class MsalAuthProvider(private val authenticationResult: IAuthenticationResult) : IAuthenticationProvider {
        override fun getAuthorizationTokenAsync(requestUrl: URL): CompletableFuture<String> {
            return CompletableFuture.completedFuture(authenticationResult.accessToken)
        }
    }
}


// Content from ReminderManager.kt
package com.app.routineturboa.reminders


class ReminderManager(private val context: Context) {
    private val notificationManager: NotificationManager = context.getSystemService(
        Context.NOTIFICATION_SERVICE) as NotificationManager
    private val alarmManager: AlarmManager = context.getSystemService(
        Context.ALARM_SERVICE) as AlarmManager

    init {
        createNotificationChannel()
    }

    private fun createNotificationChannel() {
        val channel = NotificationChannel(
            CHANNEL_ID,
            "Task Reminders",
            NotificationManager.IMPORTANCE_HIGH
        ).apply {
            description = "Notifications for task reminders"
        }
        notificationManager.createNotificationChannel(channel)
    }

    fun showNotification(taskId: Int, title: String, content: String) {
        val notification = NotificationCompat.Builder(context, CHANNEL_ID)
            .setSmallIcon(R.drawable.routineturbo)
            .setContentTitle(title)
            .setContentText(content)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setAutoCancel(true)
            .build()
        notificationManager.notify(taskId, notification)
    }

    @RequiresApi(Build.VERSION_CODES.S)
    private fun scheduleReminder(taskId: Int, reminderTime: Long) {
        Log.d("ReminderManager", "Scheduling reminder for task $taskId at $reminderTime")

        val intent = Intent(context, ReminderReceiver::class.java).apply {
            putExtra("TASK_ID", taskId)
        }

        val pendingIntent = PendingIntent.getBroadcast(
            context,
            taskId,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        alarmManager.setAndAllowWhileIdle(
            AlarmManager.RTC_WAKEUP,
            reminderTime,
            pendingIntent
        )

        alarmManager.canScheduleExactAlarms(
        )

        Log.d("ReminderManager", "Reminder scheduled for task $taskId at $reminderTime")
    }

    @RequiresApi(Build.VERSION_CODES.S)
    suspend fun observeAndScheduleReminders(context: Context) {
        Log.d("ReminderManager", "Observing and scheduling reminders")
        val dbRepository = RoutineRepository(context)

        dbRepository.getAllTasks().collect { tasks ->
            tasks.forEach { task ->
                task.reminder.let { reminderTime ->
                    try {
                        val taskName = task.name
                        val reminderTimeZoned = reminderTime.atZone(ZoneId.systemDefault())
                        val reminderTimeInMilli = reminderTimeZoned.toInstant().toEpochMilli()

                        if (reminderTimeInMilli > System.currentTimeMillis()) {
                            scheduleReminder(task.id, reminderTimeInMilli)
                            Log.d("ReminderManager", "Task: $taskName. Reminder time in system zone: $reminderTimeZoned")
                            Log.d("ReminderManager", "Scheduling Reminder: $reminderTime")

                        } else {
                            cancelReminder(task.id)
                        }

                    } catch (e: Exception) {
                        Log.e("ReminderManager", "Failed to parse reminder time ${task.id}: $reminderTime", e)
                    }
                }
            }
        }
    }


    private fun cancelReminder(taskId: Int) {
        val intent = Intent(context, ReminderReceiver::class.java)
        val pendingIntent = PendingIntent.getBroadcast(
            context,
            taskId,
            intent,
            PendingIntent.FLAG_NO_CREATE or PendingIntent.FLAG_IMMUTABLE
        )
        pendingIntent?.let {
            alarmManager.cancel(it)
            it.cancel()
        }
    }

    fun triggerReminder(taskId: Int) {
        Log.d("ReminderManager", "Triggering reminder for task $taskId")
        val intent = Intent(context, ReminderReceiver::class.java).apply {
            putExtra("TASK_ID", taskId)
        }
        context.sendBroadcast(intent)
    }

    companion object {
        const val CHANNEL_ID = "task_reminders_channel"
    }
}

// Content from ReminderReceiver.kt
package com.app.routineturboa.reminders


class ReminderReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        val taskId = intent.getIntExtra("TASK_ID", -1)
        if (taskId != -1) {
            CoroutineScope(Dispatchers.IO).launch {
                val dbRepository = RoutineRepository(context)
                val reminderManager = ReminderManager(context)
                val task = dbRepository.getTaskById(taskId)
                task?.let {
                    reminderManager.showNotification(it.id, it.type, it.name)
                }
            }
        }
    }

}

// Content from ScheduleReminders.kt


// Content from CustomTextField.kt
package com.app.routineturboa.ui.components


@Composable
fun CustomTextField(
    modifier: Modifier = Modifier,
    value: String,
    onValueChange: (String) -> Unit,
    label: String,
    keyboardOptions: KeyboardOptions = KeyboardOptions.Default,
    placeholder: String = "",
    leadingIcon: ImageVector? = null,
    leadingIconResId: Int? = null,
    enabled: Boolean = true,
    singleLine: Boolean = true
) {
    var isFocused by remember { mutableStateOf(false) }

    val backgroundColor by animateColorAsState(
        if (isFocused) MaterialTheme.colorScheme.surfaceDim.copy(alpha = 1f)
        else MaterialTheme.colorScheme.surface.copy(alpha = 0.8f),
        label = "TextField Background Color"
    )

    val textColor by animateColorAsState(
        if (isFocused) MaterialTheme.colorScheme.primary
        else MaterialTheme.colorScheme.primary.copy(alpha = 0.5f),
        label = "TextField Text Color"
    )

    TextField(
        value = value,
        onValueChange = onValueChange,
        label = {
            Text(
                text = label,
                color = textColor
            )
        },
        placeholder = { Text(placeholder) },
        leadingIcon = when {
            leadingIcon != null -> { { Icon(leadingIcon, contentDescription = null) } }
            leadingIconResId != null -> { { Icon(painterResource(id = leadingIconResId), contentDescription = null) } }
            else -> null
        },
        enabled = enabled,
        modifier = modifier
            .shadow(
                elevation = if (isFocused) 8.dp else 2.dp,
                shape = RoundedCornerShape(2.dp)
            )
            .onFocusChanged { focusState ->
                isFocused = focusState.isFocused
            }
            .then(modifier),
        shape = RoundedCornerShape(5.dp),
        colors = TextFieldDefaults.colors(
            focusedContainerColor = backgroundColor,
            unfocusedContainerColor = backgroundColor,
            disabledContainerColor = MaterialTheme.colorScheme.surface,
            focusedIndicatorColor = Color.Transparent,
            unfocusedIndicatorColor = Color.Transparent
        ),
        singleLine = singleLine,
        keyboardOptions = keyboardOptions
    )
}

// Content from DottedLine.kt
package com.app.routineturboa.ui.components


@Composable
fun DottedLine(
    color: Color,
    thickness: Dp = 0.2.dp,
    dotLength: Dp = 8.dp,
    dotSpacing: Dp = 3.dp
) {
    val density = LocalDensity.current

    val pathEffect = PathEffect.dashPathEffect(
        floatArrayOf(
            with(density) { dotLength.toPx() },
            with(density) { dotSpacing.toPx() }
        ), 0f
    )

    Canvas(
        modifier = Modifier
            .fillMaxWidth()
            .height(thickness)
    ) {
        drawLine(
            color = color,
            start = Offset(0f, 0f),
            end = Offset(size.width, 0f),
            strokeWidth = thickness.toPx(),
            pathEffect = pathEffect
        )
    }
}

// Content from SignInItem.kt
package com.app.routineturboa.ui.components


@Composable
fun SignInItem() {
    val tag = "SignInItem"
    val context = LocalContext.current
    val msalAuthManager = remember { RoutineTurboApp.instance.msalAuthManager }
    var isSignedIn by remember { mutableStateOf(false) }
    var username by remember { mutableStateOf("") }
    var isExpanded by remember { mutableStateOf(false) }
    var profileImageUrl by remember { mutableStateOf<String?>(null) }
    val coroutineScope = rememberCoroutineScope()

    val isMsalInitialized by msalAuthManager.isInitialized.collectAsState()

    LaunchedEffect(isMsalInitialized, isSignedIn) {
        if (isMsalInitialized) {
            Log.d(
                "SignInItem",
                "LaunchedEffect: msalAuthManager is initialized. Getting current account and profile image..."
            )

            msalAuthManager.getCurrentAccount { account ->
                isSignedIn = account != null
                username = account?.username ?: ""

                //strip username of @ if present
                if (username.contains("@")) {
                    username = username.substringBefore("@")
                }

                Log.d(tag, "isSignedIn:$isSignedIn and username:$username")

                if (account != null) {
                    Log.d(tag, "LaunchedEffect: account is not null. Getting profile image URL.")
                    coroutineScope.launch {
                        profileImageUrl = msalAuthManager.getProfileImageUrl()
                    }
                } else {
                    Log.d(tag, "LaunchedEffect: account is null. No profile image URL.")
                }
            }
        }

        else {
            Log.d(tag, "LaunchedEffect: msalAuthManager is not initialized yet.")
        }
    }

    fun handleSignIn() {
        coroutineScope.launch {
            try {
                val result = msalAuthManager.signIn(context as MainActivity)
                isSignedIn = true
                username = result.account.username
                profileImageUrl = msalAuthManager.getProfileImageUrl()
            } catch (e: Exception) {
                Log.e("SignInItem", "Sign-in error", e)
                Toast.makeText(context, "Sign-in error: ${e.message}", Toast.LENGTH_SHORT).show()
            }
        }
    }

    fun handleSignOut() {
        coroutineScope.launch {
            try {
                val success = msalAuthManager.signOutSuspend()
                if (success) {
                    isSignedIn = false
                    username = ""
                    profileImageUrl = null
                    isExpanded = false
                }
                // Always show a message, success or failure
                Toast.makeText(context, if (success) "Signed out successfully" else "Sign-out failed", Toast.LENGTH_SHORT).show()
            } catch (e: Exception) {
                Log.e("SignInItem", "Sign-out error", e)
                Toast.makeText(context, "Sign-out error: ${e.message}", Toast.LENGTH_SHORT).show()
            }
        }
    }

    Column {
        Row(
            verticalAlignment = Alignment.CenterVertically,
            modifier = Modifier
                .fillMaxWidth()
                .clickable {
                    if (isSignedIn) {
                        isExpanded = !isExpanded
                    } else {
                        Log.d(tag, "Sign in button clicked")
                        coroutineScope.launch {
                            handleSignIn()
                        }
                    }
                }
                .padding(16.dp)
        ) {
            if (isSignedIn) {
                AsyncImage(
                    model = profileImageUrl,
                    contentDescription = "Profile Picture",
                    modifier = Modifier
                        .size(30.dp)
                        .clip(CircleShape),
                    contentScale = ContentScale.Crop
                )
            } else {
                Icon(
                    imageVector = Icons.Default.Person,
                    contentDescription = if (isExpanded) "Collapse" else "Expand",
                    modifier = Modifier.size(30.dp)
                )
            }

            Spacer(modifier = Modifier.width(15.dp))

            Text(
                text = if (isSignedIn) username else "Sign in",
                style = MaterialTheme.typography.bodyLarge,
                modifier = Modifier.weight(1f),
                maxLines = 2,
                overflow = TextOverflow.Ellipsis
            )

            if (isSignedIn) {
                Icon(
                    imageVector = if (isExpanded) Icons.Default.KeyboardArrowUp else Icons.Default.KeyboardArrowDown,
                    contentDescription = if (isExpanded) "Collapse" else "Expand",
                    modifier = Modifier.size(24.dp)
                )
            }


        }

        AnimatedVisibility(visible = isSignedIn && isExpanded) {
            Column(
                modifier = Modifier
                    .padding(start = 56.dp, end = 16.dp, bottom = 8.dp)
            ) {
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    modifier = Modifier
                        .fillMaxWidth()
                        .clickable {
                            coroutineScope.launch {
                                handleSignOut()
                                isSignedIn = false
                                username = ""
                                profileImageUrl = null
                                isExpanded = false
                            }
                        }
                        .padding(vertical = 8.dp)
                ) {
                    Icon(
                        imageVector = Icons.AutoMirrored.Filled.ExitToApp,
                        contentDescription = "Sign out",
                        modifier = Modifier.size(24.dp)
                    )
                    Spacer(modifier = Modifier.width(16.dp))
                    Text(
                        text = "Sign out",
                        style = MaterialTheme.typography.bodyLarge
                    ) // Text
                } // Row

                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    modifier = Modifier
                        .fillMaxWidth()
                        .clickable { Log.d("SignInItem", "Sync Clicked")
                        }
                        .padding(vertical = 8.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.Sync,
                        contentDescription = "Sign out",
                        modifier = Modifier.size(24.dp)
                    )
                    Spacer(modifier = Modifier.width(16.dp))
                    Text(
                        text = "Sync",
                        style = MaterialTheme.typography.bodyLarge
                    ) // Text
                } // Row

            } // Column



        } // animated visibility4
    }
}


// Content from TaskCardPlaceholder.kt
package com.app.routineturboa.ui.components


@Composable
fun EmptyTaskCardPlaceholder (modifier: Modifier = Modifier) {
    Box(
        modifier = modifier
            .fillMaxWidth()
            .padding(20.dp)
    ) {
        // Main TaskCard and Start-End times
        Row {
            // Start-End times
            Column(
                modifier = Modifier
                    .height(110.dp)
                    .width(75.dp)
            ) {
                Text(
                    text = "..."
                )
                Text(
                    text = ""
                )
            }


            // Main Task Card With Details
            Card(
                modifier = modifier
                    .height(110.dp)
                    .fillMaxWidth(),
                colors = CardDefaults.cardColors(),
                shape = RoundedCornerShape(15.dp),
            ) {

                // Main content of the card
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(20.dp)
                ) {
                    // Task Name, Duration, Reminder
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                    ) {
                        SmoothCircularProgressIndicator()
                    }
                }
            }
        }
    }
}

@Composable
fun SmoothCircularProgressIndicator(modifier: Modifier = Modifier) {
    val infiniteTransition = rememberInfiniteTransition(label = "Loading Infinite Transition")
    val angle by infiniteTransition.animateFloat(
        initialValue = 0f,
        targetValue = 360f,
        animationSpec = infiniteRepeatable(
            animation = tween(durationMillis = 1000, easing = LinearEasing),
            repeatMode = RepeatMode.Restart
        ), label = ""
    )

    CircularProgressIndicator(
        progress = { angle / 360f },
        modifier = modifier
            .height(30.dp)
            .width(30.dp),
        color = MaterialTheme.colorScheme.primary,
        strokeWidth = 2.dp,
        trackColor = Color.LightGray,
        strokeCap = StrokeCap.Round
    )
}




// Content from MainScreen.kt
package com.app.routineturboa.ui.main


@RequiresApi(Build.VERSION_CODES.S)
@Composable
fun MainScreen(reminderManager: ReminderManager) {
    Log.d("MainScreen", "MainScreen starts...")

    val context = LocalContext.current
    val taskViewModelFactory = remember { TaskViewModelFactory(RoutineRepository(context)) }
    val tasksViewModel: TasksViewModel = viewModel(factory = taskViewModelFactory)
    val drawerState = rememberDrawerState(DrawerValue.Closed)

    val isAddingTask = remember { mutableStateOf(false) }

    ModalNavigationDrawer(
        scrimColor = MaterialTheme.colorScheme.secondary.copy(alpha = 0.2f), // Rest of the UI color on drawer open
        drawerState = drawerState,
        drawerContent = { MainDrawer(drawerState, tasksViewModel, reminderManager) },
    ) {
        Scaffold(
            //  <editor-fold desc="Main Scaffold">
            topBar = { MainTopBar(drawerState) },
            bottomBar = { MainBottomBar() },
            floatingActionButton = {
                FloatingActionButton (
                    onClick = { isAddingTask.value = true },
                    elevation = FloatingActionButtonDefaults.elevation(6.dp),
                    modifier = Modifier.padding(end = 30.dp)
                ) { Text(text = "New") }
            },
            floatingActionButtonPosition = FabPosition.End,

            // </editor-fold>
        ) { paddingValues ->
            TasksLazyColumn(paddingValues, isAddingTask, context, tasksViewModel, reminderManager)
        }
    }
}

// Content from TasksLazyColumn.kt
package com.app.routineturboa.ui.main


@OptIn(ExperimentalMaterial3Api::class)
@RequiresApi(Build.VERSION_CODES.S)
@Composable
fun TasksLazyColumn(
    paddingValues: PaddingValues,
    isAddingTask: MutableState<Boolean>,
    context: Context,
    tasksViewModel: TasksViewModel,
    reminderManager: ReminderManager
) {
    // <editor-fold desc="variables">
    val tag = "TasksLazyColumn"

    val tasks by tasksViewModel.tasks.collectAsStateWithLifecycle()
    val clickedTaskId = remember { mutableStateOf<Int?>(null) }
    val editingTaskId = remember { mutableStateOf<Int?>(null) }
    val isQuickEditing = remember { mutableStateOf(false) }
    val isFullEditing = remember { mutableStateOf(false) }
    var isAnotherTaskEditing = remember { mutableStateOf(false) }

    val hasScrolledToTarget = remember { mutableStateOf(false) }

    val authenticationResult by remember { mutableStateOf<IAuthenticationResult?>(null) }
    var isLoading by remember { mutableStateOf(true) }

    val listState = rememberLazyListState()


    // Find the index of the task whose time range includes the current time
    val targetIndex = tasks.indexOfFirst { task ->
        val currentDateTime = remember { java.time.LocalDateTime.now() }
        val startTime = task.startTime
        val endTime = task.endTime
        currentDateTime.isAfter(startTime) && currentDateTime.isBefore(endTime)
    }

    // </editor-fold variables>

    // Use LaunchedEffect to perform scrolling only once after the tasks are loaded
    LaunchedEffect(tasks) {
        if (tasks.isNotEmpty() && targetIndex != -1 && !hasScrolledToTarget.value) {
            listState.animateScrollToItem(targetIndex)
            hasScrolledToTarget.value = true // Set the flag to true after scrolling
        }
    }

    LaunchedEffect(authenticationResult, key2 = true) {
        Log.d(tag, "TasksScreen LaunchedEffect called")
        authenticationResult?.let {
            Log.d(tag, "Downloading from OneDrive")
        }
    }

    // Start a coroutine to delay the loading state change
    LaunchedEffect(tasks) {
        delay(50)
        isLoading = false
    }

    // <editor-fold desc="Lazy Column-SingleTaskCard">
    LazyColumn(
        state = listState,
        modifier = Modifier
            .padding(paddingValues),
        contentPadding = PaddingValues(bottom = 50.dp),  // Adjust the padding values as needed
        verticalArrangement = Arrangement.spacedBy(2.dp)
    ) {
        // Loading state or no tasks
        if (isLoading || tasks.isEmpty()) {
            items(2) {
                EmptyTaskCardPlaceholder()
            }
        }

        else {
            items(
                tasks, key = { task ->
                    task.id
                }
            ) { task ->
                // Determine if another task is being edited
                isAnotherTaskEditing.value = (isQuickEditing.value || isFullEditing.value) && editingTaskId.value != task.id

                TaskCard(
                    // <editor-fold desc="SingleTaskCard Parameters"
                    context = context,
                    tasksViewModel = tasksViewModel,
                    reminderManager = reminderManager,
                    task = task,
                    onClick = { clickedTaskId.value = task.id },
                    canDelete = !tasksViewModel.isTaskFirst(task) && !tasksViewModel.isTaskLast(task),
                    onDelete = { tasksViewModel.deleteTask(it) },

                    isClicked = task.id == clickedTaskId.value,
                    isAnotherTaskEditing = isAnotherTaskEditing.value,

                    isQuickEditing = isQuickEditing.value && editingTaskId.value == task.id,
                    isFullEditing = isFullEditing.value && editingTaskId.value == task.id,

                    onStartQuickEdit = {
                        editingTaskId.value = task.id
                        isQuickEditing.value = true
                        isFullEditing.value = false
                    },
                    onStartFullEdit = {
                        editingTaskId.value = task.id
                        isQuickEditing.value = false
                        isFullEditing.value = true
                    },
                    onEndEditing = {
                        editingTaskId.value = null
                        isQuickEditing.value = false
                        isFullEditing.value = false
                    }


                )
            }
        }
    }  // end of lazy column
    // </editor-fold>

    Text(
        text = tasks.find { it.id == clickedTaskId.value }?.name ?: "",
        textAlign = TextAlign.Center,
        modifier = Modifier.padding(PaddingValues())
    )

    // AddTaskDialog (Inside the parent Box)
    if (isAddingTask.value && clickedTaskId.value != null) {
        val clickedTask = tasks.find { it.id == clickedTaskId.value }
        val boxColor = Color.Black.copy(alpha = 0.3f)

        Box(modifier = Modifier.background(boxColor)) {
            AddTaskDialog(
                tasksViewModel = tasksViewModel,
                clickedTask = clickedTask,
                onAddClick = { newTask ->
                    tasksViewModel.beginNewTaskOperations(clickedTask!!, newTask)
                    isAddingTask.value = false
                },
                onCancel = { isAddingTask.value = false }
            )
        }
    }
}

// Content from BottomNavBar.kt
package com.app.routineturboa.ui.main.scaffold


@Composable
fun MainBottomBar() {
    var selectedItem by remember { mutableIntStateOf(0) }
    val items = listOf("Home", "Tasks", "Settings")
    val icons = listOf(Icons.Filled.Home, Icons.AutoMirrored.Filled.List, Icons.Filled.Settings)

    NavigationBar (
        Modifier.height(65.dp)
    ) {
        items.forEachIndexed { index, item ->
            NavigationBarItem(
                icon = { Icon(icons[index], contentDescription = item) },
                label = { Text(item) },
                selected = selectedItem == index,
                onClick = { selectedItem = index }
            )
        }
    }
}

// Content from MainDrawer.kt
package com.app.routineturboa.ui.main.scaffold


@RequiresApi(Build.VERSION_CODES.S)
@Composable
fun MainDrawer(
    drawerState: DrawerState,
    tasksViewModel: TasksViewModel,
    reminderManager: ReminderManager
) {
    val context = LocalContext.current
    val appName = context.getString(R.string.app_name)
    val coroutineScope = rememberCoroutineScope()

    val configuration = LocalConfiguration.current
    val screenWidth = configuration.screenWidthDp.dp
    val screenHeight = configuration.screenHeightDp.dp

    ModalDrawerSheet(
        //region ModalDrawerSheet Parameters
        drawerContainerColor = MaterialTheme.colorScheme.surface,
        drawerContentColor = MaterialTheme.colorScheme.onSurface,
        drawerTonalElevation = 9.dp,

        modifier = Modifier
            .width(screenWidth * 0.7f)
            .height(screenHeight * 0.90f)
            .padding(top = 12.dp)
            .offset(x = if (drawerState.isClosed) - screenWidth else 0.dp)
            .shadow(15.dp),
        drawerShape = RectangleShape
        //endregion
    ) {
        // Content inside drawer
        Column(
            modifier = Modifier
                .fillMaxSize()
                .verticalScroll(rememberScrollState())
        ) {
            // Top Header
            Surface(
                color = MaterialTheme.colorScheme.primary,
                modifier = Modifier.shadow(15.dp)
            ) {
                // Top Item with App Name
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.SpaceBetween,
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 12.dp, horizontal = 10.dp)
                ) {
                    // region App Main Icon
                    Image(
                        painter = painterResource(id = R.drawable.routineturbo),
                        contentDescription = "App Icon",
                        modifier = Modifier
                            .size(40.dp)
                            .clip(CircleShape)
                    )
                    // endregion

                    Spacer(modifier = Modifier.width(10.dp))

                    Text(
                        text = appName,
                        style = MaterialTheme.typography.titleMedium,
                        color = MaterialTheme.colorScheme.onPrimary
                    )

                    Spacer(modifier = Modifier.weight(1f))

                    Icon(
                        Icons.AutoMirrored.Outlined.MenuOpen,
                        contentDescription = null, // Handle accessibility if needed
                        modifier = Modifier
                            .size(24.dp) // Adjust size as necessary
                            .clickable {
                                coroutineScope.launch { drawerState.close() }
                            },
                        tint = Color.Gray
                    )
                }
            }

            SignInItem()

            // schedule reminders
            DrawerItemTemplate("Schedule Reminders", Icons.Default.Build) {
                coroutineScope.launch {
                    reminderManager.observeAndScheduleReminders(context)
                }
            }

            // Insert Demo Tasks
            DrawerItemTemplate("Insert Demo Tasks", Icons.Default.Settings) {
                tasksViewModel.insertDemoTasks()
            }
        }
    }
}

@Composable
fun DrawerItemTemplate(text: String, icon: ImageVector, onItemClick: () -> Unit) {
    Row(
        verticalAlignment = Alignment.CenterVertically,
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onItemClick)
            .padding(16.dp)
    ) {
        Icon(
            imageVector = icon,
            contentDescription = null, // Handle accessibility if needed
            modifier = Modifier.size(24.dp) // Adjust size as necessary
        )
        Spacer(modifier = Modifier.width(16.dp)) // Adjust spacing between icon and text
        Text(
            text = text,
            style = MaterialTheme.typography.bodyLarge
        )
    }
}



// Content from MainTopBar.kt
package com.app.routineturboa.ui.main.scaffold


@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MainTopBar(drawerState: DrawerState) {
    val currentDate: String = SimpleDateFormat("MMMM d",
        Locale.getDefault()).format(Date())
    val coroutineScope = rememberCoroutineScope()

    val scrollBehavior = exitUntilCollapsedScrollBehavior()

    TopAppBar(
        //<editor-fold desc="TopAppBar Parameters">
        colors = TopAppBarDefaults.largeTopAppBarColors(
            containerColor = MaterialTheme.colorScheme.primary,
            titleContentColor = MaterialTheme.colorScheme.onPrimary,
        ),
        title = { Text(text = currentDate) },
        navigationIcon = {
            IconButton(
                onClick = { coroutineScope.launch { drawerState.open() } }
            ) {
                Icon(
                    Icons.Outlined.Menu,
                    contentDescription = "Menu"
                )
            }
        },
        actions = {
            IconButton(
                onClick = { /*TODO: Main Top Bar button action.*/ }
            ) {
                Icon(
                    Icons.Outlined.ViewDay,
                    contentDescription = "View Day"
                )
            }
        },
        scrollBehavior = scrollBehavior,
        //</editor-fold>
    )
}


// Content from QuickEdit.kt
package com.app.routineturboa.ui.task


@RequiresApi(Build.VERSION_CODES.S)
@Composable
fun QuickEdit(
    task: TaskEntity,
    onEndEditing: () -> Unit,
    tasksViewModel: TasksViewModel,
    reminderManager: ReminderManager,
    context: Context
) {
    val tag = "QuickEditScreen"
    val isFullEditing = remember { mutableStateOf(false) }

    val startTime by remember { mutableStateOf(task.startTime) }
    var taskName by remember { mutableStateOf(task.name) }

    var duration by remember { mutableIntStateOf(task.duration) }
    var durationString by remember { mutableStateOf(duration.toString()) }

    var endTime by remember { mutableStateOf(task.endTime) }
    var endTimeString by remember { mutableStateOf(dateTimeToString(endTime)) }


    LaunchedEffect(durationString) {
        if (durationString.isNotEmpty()) {
            try {
                endTimeString = dateTimeToString(startTime.plusMinutes(durationString.toLong()))

            } catch (e: NumberFormatException) {
                Toast.makeText(context, "Invalid duration format", Toast.LENGTH_SHORT).show()
            }
        }
    } // end of LaunchedEffect for Duration

    fun beginTaskUpdateOperations(updatedTask: TaskEntity) {
        Log.d(tag, "Starting task update operations...")
        tasksViewModel.updateTaskAndAdjustNext(updatedTask)
    }

    TextField(
    value = taskName,
    onValueChange = { taskName = it },
    label = { Text("Task Name") }
    )

    TextField(
    value = durationString,
    onValueChange = { durationString = it },
    label = { Text("Duration (minutes)") }
    )

    TextField(
    value = endTimeString,
    onValueChange = { endTimeString = it },
    label = { Text("End Time") }
    )

    Row(
    modifier = Modifier.fillMaxWidth(),
    horizontalArrangement = Arrangement.SpaceBetween
    ) {
        // Cancel Button
        TextButton(onClick = { onEndEditing() }) {
            Text("Cancel")
        }

        // Save Button
        ExtendedFloatingActionButton (
            // <editor-fold desc="Save button with onClick function">
            modifier = Modifier.padding(end = 20.dp),

            // On Save Button in Quick-Edit Clicked
            onClick = {
                Toast.makeText(context, "Saving....", Toast.LENGTH_SHORT).show()
                Log.d(tag, "Save Button in Quick-Edit Screen clicked...")
                try{
                    duration = durationString.toInt()
                    endTime = strToDateTime(endTimeString)

                } catch (e: Exception) {
                    Log.e(tag, "Error: $e")
                    Toast.makeText(context, "Error saving task values: ${e.message}", Toast.LENGTH_LONG).show()
                }

                Log.d(tag, "New Edited Task Details. Name: $taskName, Duration: $duration, End Time: $endTime")

                val taskWithUpdatedData = task.copy(
                    name = taskName,
                    duration = duration,
                    endTime = endTime
                )
                tasksViewModel.updateTaskAndAdjustNext(taskWithUpdatedData)
                onEndEditing()
            }
        // </editor-fold>
        )

        {
            Text(
                text = "Save",
            )
        }

        // Full Screen Editing
        Icon(
            imageVector = Icons.Default.Edit,
            contentDescription = "Full-Screen Editing",
            modifier = Modifier.clickable{
                isFullEditing.value = true
            }
                .align(Alignment.CenterVertically)
        )

        if (isFullEditing.value) {
            FullEditDialog(
                task = task,
                onConfirmTaskEdit = { updatedTask ->
                    isFullEditing.value = false
                    tasksViewModel.updateTaskAndAdjustNext(updatedTask)
                    onEndEditing()
                },
                onCancel = {
                    isFullEditing.value = false
                }
            )
        }
    }
}

// Content from TaskCard.kt
package com.app.routineturboa.ui.task


@RequiresApi(Build.VERSION_CODES.S)
@Composable
fun TaskCard(
    context: Context,
    tasksViewModel: TasksViewModel,
    reminderManager: ReminderManager,
    modifier: Modifier = Modifier,
    task: TaskEntity,
    onClick: () -> Unit,
    canDelete: Boolean,
    onDelete: (TaskEntity) -> Unit,
    isClicked: Boolean,
    isAnotherTaskEditing: Boolean,
    isQuickEditing: Boolean,
    isFullEditing: Boolean,
    onStartQuickEdit: () -> Unit,
    onStartFullEdit: () -> Unit,
    onEndEditing: () -> Unit
) {
    // <editor-fold desc="variables">
    var expanded by remember { mutableStateOf(false) }
    var longPressOffset by remember { mutableStateOf(Offset.Zero) }

    val density = LocalDensity.current
    var showNotesDialog by remember { mutableStateOf(false) }
    val taskType = task.type

    val formattedStartTime = task.startTime.format(DateTimeFormatter.ofPattern("hh:mm a"))
    val startTimeHourString = formattedStartTime.substring(0, 2)
    val startTimeMinuteString = formattedStartTime.substring(3, 5)
    val startTimeAinAm = formattedStartTime.substring(6, 7)
    val startTimeMinAm = formattedStartTime.substring(7, 8)

    val currentTime = LocalDateTime.now()
    val isTaskNow = currentTime.isAfter(task.startTime) && currentTime.isBefore(task.endTime)
    val infiniteTransition = rememberInfiniteTransition(label = "BorderAnimation")

    var isShowTaskDetails by remember { mutableStateOf(false) }

    val taskHeight: Dp = when {
        isQuickEditing -> 220.dp // if in-edit mode
        task.type == "QuickTask" -> 45.dp
        task.type == "MainTask" -> 75.dp
        else -> 75.dp // Default height, in case there are other task types
    }

    val borderAlpha by infiniteTransition.animateFloat(
        // <editor-fold desc="borderAlpha for current Task">
        initialValue = 0.2f,
        targetValue = 0.5f,
        animationSpec = infiniteRepeatable(
            animation = tween(500, easing = SineEasing),
            repeatMode = RepeatMode.Reverse
        ), label = "BorderAlpha"
        // </editor-fold>
    )

    val backgroundColor = if (isAnotherTaskEditing) {
        LocalCustomColorsPalette.current.gray200.copy(alpha=0.8f) // Grey when another task is being edited
    } else {
        MaterialTheme.colorScheme.surface.copy(alpha=0.8f) // Grey when another task is being edited
    }

    val dottedLineColor = when {
        isClicked -> MaterialTheme.colorScheme.secondary.copy(alpha = 0.5f)
        else -> MaterialTheme.colorScheme.secondary.copy(alpha = 0.2f)
    }

    val cardBorder = when {
        isTaskNow -> BorderStroke(
            width = 3.dp,
            color = MaterialTheme.colorScheme.primary.copy(alpha = borderAlpha)
        )
        isClicked -> BorderStroke(
            width = 1.dp,
            color = MaterialTheme.colorScheme.secondary.copy(alpha = 0.5f)
        )
        else -> null
    }

    // </editor-fold>

    // <editor-fold desc="Main Box container that contains everything except 'show notes' dialog">
    Box(
        // <editor-fold desc="modifier.pointerInput (clicking behavior)">
        modifier = modifier
            .alpha(if (isAnotherTaskEditing) 0.5f else 1f)
            .fillMaxWidth()
            .pointerInput(Unit) {
                detectTapGestures(
                    onLongPress = { offset ->
                        longPressOffset = offset
                        expanded = true
                        onClick()
                        Log.d("SingleTaskCard", "Long Press Offset: $longPressOffset")

                    },
                    onTap = {
                        onClick()
                    }
                )
            }
    ) // </editor-fold>
    {
        // <editor-fold desc="Dotted Line at top">
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .offset(x = 0.dp, y = 2.dp)
                .align(Alignment.TopStart)
        ) {
            DottedLine(
                color = dottedLineColor,
                thickness = if (isClicked) 2.dp else 0.5.dp
            )
        }
        // </editor-fold "dotted Line">

        Row {
            // StartTime Hour:Minute Column
            Row (
            // <editor-fold desc="StartTime Hour:Minute Column">
                verticalAlignment = Alignment.CenterVertically,
                modifier = Modifier
                    .height(taskHeight)
                    .width(40.dp)
                    .padding(
                        start = 10.dp,
                        end = 1.dp,
                        top = 5.dp,
                    )
            // </editor-fold "StartTime Hour:Minute Column">
            ) {
                // Hour and Minute Column
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy((-8).dp),
                ) {
                    Text(
                        text = startTimeHourString,
                        style = MaterialTheme.typography.bodyLarge.copy(fontSize = 14.sp),
                    )

                    Text(
                        text = startTimeMinuteString,
                        style = MaterialTheme.typography.bodyLarge.copy(fontSize = 14.sp),
                    )
                }

                // A/P and M Column
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy((-10).dp), // Adjust to control space between A/P and M
                ) {
                    Text(
                        text = startTimeAinAm, // A or P
                        style = MaterialTheme.typography.bodyLarge.copy(fontSize = 12.sp,
                            color = MaterialTheme.colorScheme.secondary),
                    )
                    Text(
                        text = startTimeMinAm, // M
                        style = MaterialTheme.typography.bodyLarge.copy(fontSize = 12.sp,
                            color = MaterialTheme.colorScheme.secondary),
                    )
                }
            }
            // End of Column (Hour Column on Left)

            Spacer(modifier = Modifier.width(5.dp))

            Card(
                // <editor-fold desc = "Card (for Main Task)"
                modifier = modifier
                    .height(taskHeight)
                    .fillMaxWidth()
                    .padding(
                        start = if (taskType == "QuickTask") 0.dp else 4.dp,
                        end = 10.dp, top = 1.dp, bottom = 0.dp
                    )
                    .graphicsLayer {
                        clip = true
                        shadowElevation = if (isClicked) 0f else 0f // Increased shadow elevation
                        shape = RoundedCornerShape(0.dp)
                        spotShadowColor =
                            Color.Blue // Changed shadow color to black for more prominence
                        ambientShadowColor =
                            Color.Yellow // Ambient shadow color can be adjusted as well
                    },
                colors = CardDefaults.cardColors(
                    containerColor = backgroundColor
                ),
                shape = RoundedCornerShape(0.dp),
                border = cardBorder
                // </editor-fold>
            ) {
                // Layout for Main content of the card
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(
                            if (isQuickEditing) 2.dp else 15.dp,
                            if (isQuickEditing) 2.dp else 4.dp,
                            8.dp,
                            0.dp,
                        )
                        .height(taskHeight)
                ) {
                    // If editing (in-place)
                    if (isQuickEditing) {
                        QuickEdit(
                            task = task,
                            onEndEditing = { onEndEditing() },
                            tasksViewModel = tasksViewModel,
                            reminderManager = reminderManager,
                            context = context
                        )
                    }

                    // if to show Task Details
                    if (isShowTaskDetails) {
                        TaskDetailsDialog(task = task,
                            onDismiss = { isShowTaskDetails = false })
                    }

                    else {
                        // <editor-fold desc="Main Interface (not in edit mode)"

                        // Task Name, Show Notes and Edit Icon
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            // Task Name
                            Text(
                                // <editor-fold desc="Task Name "
                                text = task.name,
                                style = MaterialTheme.typography.titleMedium,
                                maxLines = 1,
                                overflow = TextOverflow.Ellipsis,
                                modifier = Modifier
                                    .weight(1f)
                                // </editor-fold>
                            )

                            // Show notes
                            IconButton(
                                // <editor-fold desc="Show Notes"
                                onClick = { showNotesDialog = true },
                                modifier = Modifier
                                    .alpha(if (taskType == "QuickTask") 0f else 0.5f)
                                    .size(25.dp)
                                    .padding(end = 10.dp)
                            ) {
                                Icon(
                                    imageVector = Icons.AutoMirrored.Sharp.LibraryBooks,
                                    contentDescription = "Show Notes",
                                    tint = if (isClicked) MaterialTheme.colorScheme.secondary.copy(alpha = 1f)
                                            else MaterialTheme.colorScheme.primary.copy(alpha = 0.4f)
                                )
                            }
                            // </editor-fold>

                            Spacer(modifier = Modifier.width(15.dp))

                            // Quick-Edit Button
                            IconButton(
                                // <editor-fold desc="Quick-Edit Icon "
                                onClick = {
                                    onStartQuickEdit()
                                },
                                modifier = Modifier
                                    .alpha(if (taskType == "QuickTask") 0.5f else 0.7f)
                                    .size(16.dp)
                            ) {
                                Icon(
                                    imageVector = Icons.Default.Edit,
                                    contentDescription = "Edit Task",
                                    tint = if (isClicked) MaterialTheme.colorScheme.surfaceTint.copy(alpha = 1f)
                                    else MaterialTheme.colorScheme.primary.copy(alpha = 0.6f)
                                )
                            }
                            // </editor-fold>

                            // </editor-fold>
                        }

                        // start, end, duration all combined
                        if (taskType != "QuickTask") {
                            Spacer(modifier = Modifier.height(8.dp))

                            // Layout for start, end, duration all combined
                            Row(
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Icon(
                                    imageVector = Icons.Default.AccessTime,
                                    contentDescription = "End Time",
                                    tint = MaterialTheme.colorScheme.primary.copy(alpha = 0.6f),
                                    modifier = Modifier.size(16.dp)
                                )
                                Text(
                                    text = buildAnnotatedString {
                                        append("")
                                        withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {
                                            append(task.startTime.format(DateTimeFormatter.ofPattern("hh:mm a")))
                                        }
                                        append(" to ")
                                        withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {
                                            append(task.endTime.format(DateTimeFormatter.ofPattern("hh:mm a")))
                                        }
                                        append(" | ")
                                        withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {
                                            append(task.duration.toString())
                                        }
                                        append(" mins ")
                                    },
                                    style = MaterialTheme.typography.labelSmall,
                                    color = MaterialTheme.colorScheme.onTertiaryContainer.copy(alpha = 0.3f),
                                    modifier = Modifier.padding(start = 4.dp)
                                )
                            }
                        }

                        // </editor-fold>
                    }
                }
            } // End of Main Task-Card Details
        }

        // </editor-fold>

        // <editor-fold desc="Dropdown Menu">
        if (expanded){
            TaskDropdownMenu(
                onEditClick = {
                    expanded = false
                    onStartFullEdit()
                },
                canDelete = canDelete,
                onDeleteClick = {
                    expanded = false
                    if (canDelete) {
                        onDelete(task)
                    }
                },
                onViewClick = { isShowTaskDetails = true },
                onDismissRequest = { expanded = false },
                offset = DpOffset(
                    x = with(density) { longPressOffset.x.toDp() + 10.dp },
                    y = with(density) { longPressOffset.y.toDp() - 112.dp }
                )
            )
        }
        // </editor-fold>

    } // End of main parent Box
    // </editor-fold>

    // <editor-fold desc="Dialog to show notes"
    if (showNotesDialog) {
        AlertDialog(
            onDismissRequest = { showNotesDialog = false },
            title = { Text(text = "Task Notes") },
            text = { Text(text = task.notes) },
            confirmButton = {
                Button(onClick = { showNotesDialog = false }) {
                    Text("Close")
                }
            }
        )
    }
    // </editor-fold>
}

// Content from TaskDropdown.kt
package com.app.routineturboa.ui.task



@Composable
fun TaskDropdownMenu(
    modifier: Modifier = Modifier,
    onEditClick: () -> Unit,
    onViewClick: () -> Unit,
    canDelete: Boolean,
    onDeleteClick: () -> Unit,
    onDismissRequest: () -> Unit,
    offset: DpOffset,
) {
    DropdownMenu(
        expanded = true,
        onDismissRequest = onDismissRequest,
        offset = offset,
    ) {
        DropdownMenuItem(
            text = {
                Text(
                    text = "Edit",
                    style = MaterialTheme.typography.bodyLarge,
                    color = MaterialTheme.colorScheme.onPrimaryContainer,
                )
            },
            onClick = onEditClick,
        )

        HorizontalDivider(
            thickness = 2.dp
        )

        DropdownMenuItem(
            text = {
                Text(
                    text = "View Details",
                    style = MaterialTheme.typography.bodyLarge,
                    color = if (canDelete) {
                        MaterialTheme.colorScheme.onPrimaryContainer
                    } else {
                        MaterialTheme.colorScheme.onSurfaceVariant
                    },
                    modifier = Modifier
                        .alpha(if (canDelete) 1f else 0.3f)
                )
            },
            onClick = onViewClick,
            colors = MenuDefaults.itemColors(
                disabledTextColor = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.9f)
            )
        )

        DropdownMenuItem(
            text = {
                Text(
                    text = "Delete",
                    style = MaterialTheme.typography.bodyLarge,
                    color = if (canDelete) {
                        MaterialTheme.colorScheme.onPrimaryContainer
                    } else {
                        MaterialTheme.colorScheme.onSurfaceVariant
                    },
                    modifier = Modifier
                        .alpha(if (canDelete) 1f else 0.3f)
                )
            },
            onClick = onDeleteClick,
            enabled = canDelete,
            colors = MenuDefaults.itemColors(
                disabledTextColor = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.9f)
            )
        )
    }
}

// Content from AddTaskDialog.kt
package com.app.routineturboa.ui.task.dialogs



@Composable
fun AddTaskDialog(
    tasksViewModel: TasksViewModel,
    clickedTask: TaskEntity?,
    onAddClick: (TaskEntity) -> Unit,
    onCancel: () -> Unit
) {
    val tag = "AddTaskDialog"

    if (clickedTask == null) {
        Log.e(tag, "clickedTask is null")
        Toast.makeText(LocalContext.current, "Click a task first.", Toast.LENGTH_SHORT).show()
        return
    }

    Log.d(tag, "clickedTask: $clickedTask")

    // Context and Initial Task Data
    val context = LocalContext.current
    val clickedTaskEndTime = clickedTask.endTime
    val clickedTaskID = clickedTask.id
    val clickedTaskPosition = clickedTask.position

    // Fetch tasks of type "MainTask"
    val mainTasks = tasksViewModel.getMainTasks().collectAsState(initial = emptyList())

    // Data in State variables
    val id by remember { mutableIntStateOf(clickedTaskID + 1) }
    var startTime by remember { mutableStateOf(clickedTaskEndTime) }
    val defaultDuration = 1L
    var endTime by remember { mutableStateOf(startTime.plusMinutes(defaultDuration)) }
    var taskName by remember { mutableStateOf(" ") }
    var notes by remember { mutableStateOf( " ") }
    var duration by remember { mutableLongStateOf(defaultDuration) }
    var reminder by remember { mutableStateOf(startTime) }
    var taskType by remember { mutableStateOf("") }
    var taskPosition by remember { mutableIntStateOf(clickedTaskPosition.plus(1)) }

    // Convert state variables to  string for display
    var startTimeFormatted by remember {mutableStateOf(dateTimeToString(startTime))}
    var endTimeFormatted by remember {mutableStateOf(dateTimeToString(endTime))}
    var reminderFormatted by remember {mutableStateOf(dateTimeToString(reminder))}
    var durationFormatted by remember {mutableStateOf(duration.toString())}
    val idFormatted by remember {mutableStateOf(id.toString())}
    var positionFormatted by remember {mutableStateOf(taskPosition.toString())}

    // Get duration fo task below to check limits of duration for new task
    val taskBelowBeforeAdding = tasksViewModel.fetchNextTask(clickedTask!!)
    val durationTaskBelowBeforeAdding = taskBelowBeforeAdding?.duration

    var isReminderLinked by remember { mutableStateOf(true) }

    Log.d(tag, "clicked task name and position: ${clickedTask.name} ${clickedTask.position}")
    Log.d(tag, "clicked task end time: ${clickedTask.endTime}")
    Log.d(tag, "new task start time: $startTimeFormatted")

    // State to hold selected main task ID
    var linkedMainTaskIdIfHelper by remember { mutableStateOf<Int?>(null) }

    // Calculate endTime based on duration input
    LaunchedEffect(durationFormatted) {
        if (durationFormatted.isNotEmpty()) {
            try {
                val durationLong = durationFormatted.toLong()
                if (durationLong > 0 || durationLong < durationTaskBelowBeforeAdding!!) {
                    endTimeFormatted = dateTimeToString(startTime.plusMinutes(durationLong))
                } else {
                    Toast.makeText(context, "Invalid duration. End time unchanged.", Toast.LENGTH_SHORT).show()
                }
            } catch (e: NumberFormatException) {
                Toast.makeText(context, "Invalid duration format. End time unchanged.", Toast.LENGTH_SHORT).show()
            }
        } else {
            Toast.makeText(context, "Duration is empty. End time unchanged.", Toast.LENGTH_SHORT).show()
        }
    }

    // Calculate Duration based on End Time
    LaunchedEffect(endTimeFormatted) {
        if (endTimeFormatted.isNotEmpty()) {
            try {
                // Attempt to parse the end time string
                val endTimeParsed = strToDateTime(endTimeFormatted)

                if (endTimeParsed.isAfter(startTime)) {
                    // Calculate the duration in minutes
                    val durationInMinutes = java.time.Duration.between(startTime, endTimeParsed).toMinutes()

                    // Update the durationFormatted state variable
                    durationFormatted = durationInMinutes.toString()
                } else {
                    // End time is not valid or is not after start time
                    Toast.makeText(context, ".", Toast.LENGTH_SHORT).show()
                }
            } catch (e: Exception) {
                // Handle any unexpected exceptions
                Toast.makeText(context, "Error processing end time.", Toast.LENGTH_SHORT).show()
            }
        }
    }

    // Update reminder time if linked
    LaunchedEffect(startTimeFormatted) {
        if (isReminderLinked) {
            reminderFormatted = startTimeFormatted
        }
    }

    // Listen for changes in the task type dropdown
    LaunchedEffect(taskType) {
        if (taskType == "HelperTask") {
            // Reset selectedMainTaskId when task type is changed to HelperTask
            linkedMainTaskIdIfHelper = null
        }
    }

    Dialog(
        onDismissRequest = { onCancel() },
        properties = DialogProperties(usePlatformDefaultWidth = false),
    ) {
        Surface(
            modifier = Modifier
                .fillMaxWidth(0.9f),
            color = MaterialTheme.colorScheme.secondaryContainer,
            contentColor = MaterialTheme.colorScheme.onSecondaryContainer
        ) {
            Column(
                modifier = Modifier
                    .padding(8.dp)
                    .fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(10.dp)
            ) {
                Text("Add New Task", style = MaterialTheme.typography.titleLarge)

                CustomTextField(
                    value = taskName,
                    onValueChange = { taskName = it },
                    label = "Task Name",
                    placeholder = "Enter task name",
                    leadingIcon = Icons.Default.AddTask,
                    modifier = Modifier.fillMaxWidth()
                )

                // Start Time and Reminder Side by Side with Link/Link-off button
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    CustomTextField(
                        value = startTimeFormatted,
                        onValueChange = { startTimeFormatted = it },
                        label = "Start Time",
                        placeholder = "Enter start time",
                        leadingIcon = Icons.Sharp.Start,
                        modifier = Modifier.weight(1f),
                    )

                    Icon (
                        imageVector = if (isReminderLinked) Icons.Default.Link else Icons.Default.LinkOff,
                        contentDescription = "Link Reminder",
                        modifier = Modifier
                            .clickable {
                                isReminderLinked = !isReminderLinked
                                if (isReminderLinked) {
                                    reminderFormatted = startTimeFormatted
                                }
                            }
                            .align(Alignment.CenterVertically)
                            .size(30.dp)
                    )

                    CustomTextField(
                        value = reminderFormatted,
                        onValueChange = { reminderFormatted = it },
                        label = "Reminder",
                        placeholder = "Enter reminder time",
                        leadingIcon = Icons.Sharp.AddAlert,
                        enabled = !isReminderLinked,
                        modifier = Modifier.weight(1f)
                    )
                }

                // Duration and End Time Side by Side
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    CustomTextField(
                        value = durationFormatted,
                        onValueChange = { durationFormatted = it },
                        label = "Duration",
                        placeholder = "Enter duration",
                        leadingIcon = Icons.Sharp.Timer,
                        keyboardOptions = KeyboardOptions.Default.copy(keyboardType = KeyboardType.Number),
                        modifier = Modifier.weight(1f),
                    )

                    CustomTextField(
                        value = endTimeFormatted,
                        onValueChange = { endTimeFormatted = it },
                        label = "End Time",
                        placeholder = "Enter End Time",
                        leadingIconResId = R.drawable.arrowrighttoleft,
                        modifier = Modifier.weight(1f),
                    )
                }

                CustomTextField(
                    value = notes,
                    onValueChange = { notes = it },
                    label = "Notes",
                    placeholder = "Add Notes",
                    leadingIcon = Icons.Default.Link,
                    modifier = Modifier
                        .fillMaxWidth(),
                    singleLine = false
                )

                // Task type dropdown
                TaskTypeDropdown(
                    selectedTaskType = taskType,
                    onTaskTypeSelected = { newType ->
                        taskType = newType
                    }
                )

                // Show the main task dropdown only if task type is "HelperTask"
                if (taskType == "HelperTask") {
                    MainTaskDropdown(
                        mainTasks = mainTasks.value,
                        selectedMainTaskId = linkedMainTaskIdIfHelper,
                        onTaskSelected = { taskId -> linkedMainTaskIdIfHelper = taskId }
                    )
                }

                TextField(
                    value = idFormatted,
                    onValueChange = { },
                    label = { Text("Task ID") },
                    enabled = false,
                    modifier = Modifier.fillMaxWidth(),
                )

                CustomTextField(
                    value = positionFormatted,
                    onValueChange = {positionFormatted = it},
                    label = "Position (Don't Change) (Only for dev)",
                    placeholder = "Internal purposes. Don't change.",
                    modifier = Modifier.fillMaxWidth(),
                    enabled = true
                )

                Row(
                    horizontalArrangement = Arrangement.SpaceBetween,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    // Cancel Button
                    Button(
                        modifier = Modifier.padding(5.dp),
                        shape = RoundedCornerShape(25.dp),
                        onClick = { onCancel() }
                    ) { Text("Cancel") }

                    // Add Button
                    Button(
                        modifier = Modifier.padding(5.dp),
                        shape = RoundedCornerShape(25.dp),
                        onClick = {
                            if (taskName.isNotBlank() && duration > 0) {
                                startTime = strToDateTime(startTimeFormatted)
                                endTime = strToDateTime(endTimeFormatted)
                                reminder = strToDateTime(reminderFormatted)
                                duration = durationFormatted.toLong()
                                taskPosition = positionFormatted.toInt()

                                val newTask = TaskEntity(
                                    position = taskPosition,
                                    name = taskName,
                                    notes = notes,
                                    startTime = startTime,
                                    endTime = endTime,
                                    duration = duration.toInt(),
                                    reminder = reminder,
                                    type = taskType,
                                    mainTaskId = linkedMainTaskIdIfHelper // Link to the selected main task
                                )
                                onAddClick(newTask)

                            } else {
                                Toast.makeText(context,
                                    "Please fill all fields correctly", Toast.LENGTH_SHORT).show()
                            }
                        }
                    ) { Text("Add")}  // END Add Button
                }  // Buttons Row
            }
        }
    }
}


@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun TaskTypeDropdown(
    selectedTaskType: String,
    onTaskTypeSelected: (String) -> Unit
) {
    val taskTypes = listOf("MainTask", "QuickTask", "HelperTask")
    val expanded = remember { mutableStateOf(false) }

    ExposedDropdownMenuBox(
        expanded = expanded.value,
        onExpandedChange = { expanded.value = it },
        modifier = Modifier.fillMaxWidth(),
    ) {
        TextField(
            readOnly = true,
            value = selectedTaskType,
            onValueChange = {},
            label = { Text("Task Type") },
            trailingIcon = {
                ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded.value)
            },
            modifier = Modifier
                .fillMaxWidth()
                .menuAnchor()
        )
        ExposedDropdownMenu(
            expanded = expanded.value,
            onDismissRequest = { expanded.value = false },
            modifier = Modifier.fillMaxWidth()
        ) {
            taskTypes.forEach { taskType ->
                DropdownMenuItem(
                    onClick = {
                        onTaskTypeSelected(taskType) // Notify parent of the selection
                        expanded.value = false
                    },
                    text = { Text(taskType) },
                    modifier = Modifier.fillMaxWidth()
                )
            }
        }
    }
}


// Add a new composable to show the MainTask dropdown
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MainTaskDropdown(
    mainTasks: List<TaskEntity>,
    selectedMainTaskId: Int?,
    onTaskSelected: (Int?) -> Unit
) {
    val expanded = remember { mutableStateOf(false) }
    val selectedTaskName = remember(selectedMainTaskId) {
        mainTasks.find { it.id == selectedMainTaskId }?.name ?: "Select a task"
    }

    ExposedDropdownMenuBox(
        expanded = expanded.value,
        onExpandedChange = { expanded.value = it },
        modifier = Modifier.fillMaxWidth(),
    ) {
        TextField(
            readOnly = true,
            value = selectedTaskName,
            onValueChange = {},
            label = { Text("Link to Main Task") },
            trailingIcon = {
                ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded.value)
            },
            modifier = Modifier
                .fillMaxWidth()
                .menuAnchor()
        )

        ExposedDropdownMenu(
            expanded = expanded.value,
            onDismissRequest = { expanded.value = false },
            modifier = Modifier.fillMaxWidth()
        ) {
            mainTasks.forEach { task ->
                DropdownMenuItem(
                    onClick = {
                        onTaskSelected(task.id)
                        expanded.value = false
                    },
                    text = { Text(task.name) }
                )
            }
        }
    }
}

// Content from FullEditDialog.kt
package com.app.routineturboa.ui.task.dialogs


@RequiresApi(Build.VERSION_CODES.S)
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun FullEditDialog(
    task: TaskEntity,
    onConfirmTaskEdit: suspend (TaskEntity) -> Unit,
    onCancel: () -> Unit
) {
    val context = LocalContext.current

    // Actual data in State variables from 'task'
    var id by remember { mutableIntStateOf(task.id) }
    var taskName by remember { mutableStateOf(task.name) }
    var notes by remember { mutableStateOf(task.notes) }
    var startTime by remember { mutableStateOf(task.startTime) }
    var endTime by remember { mutableStateOf(task.endTime) }
    var duration by remember { mutableIntStateOf(task.duration) }
    var reminder by remember { mutableStateOf(task.reminder) }
    var position by remember { mutableIntStateOf(task.position) }
    var taskType by remember { mutableStateOf(task.type) }

    // Convert state variables to  string for display
    var startTimeString by remember {mutableStateOf(dateTimeToString(startTime))}
    var endTimeString by remember {mutableStateOf(dateTimeToString(endTime))}
    var reminderString by remember {mutableStateOf(dateTimeToString(reminder))}
    var durationString by remember {mutableStateOf(duration.toString())}
    val idFormatted by remember {mutableStateOf(id.toString())}
    var positionString by remember {mutableStateOf(position.toString())}

    val coroutineScope = rememberCoroutineScope()
    var isReminderLinked by remember { mutableStateOf(true) }

    Dialog(
        onDismissRequest = {onCancel()},
        properties = DialogProperties(usePlatformDefaultWidth = false),
    ) {
        Surface(
            modifier = Modifier
                .fillMaxWidth(0.9f),
            color = MaterialTheme.colorScheme.secondaryContainer,
            contentColor = MaterialTheme.colorScheme.onSecondaryContainer
        ) {
            Column(
                modifier = Modifier
                    .padding(8.dp)
                    .fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(10.dp)
            ) {
                Text("Edit Task", style = MaterialTheme.typography.titleLarge)

                CustomTextField(
                    value = taskName,
                    onValueChange = { taskName = it },
                    label = "Task Name",
                    placeholder = "Enter task name",
                    leadingIcon = Icons.Default.AddTask,
                    modifier = Modifier.fillMaxWidth()
                )

                // Start Time and Reminder Side by Side with Link/Link-off button
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(2.dp),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    CustomTextField(
                        value = startTimeString,
                        onValueChange = { startTimeString = it },
                        label = "Start Time",
                        placeholder = "Enter start time",
                        leadingIcon = Icons.Sharp.Start,
                        modifier = Modifier.weight(1f),
                    )

                    Icon (
                        imageVector = if (isReminderLinked) Icons.Default.Link
                        else Icons.Default.LinkOff,
                        contentDescription = "Link Reminder",
                        modifier = Modifier
                            .clickable {
                                isReminderLinked = !isReminderLinked
                                if (isReminderLinked) {
                                    reminderString = startTimeString
                                }
                            }
                            .align(Alignment.CenterVertically)
                            .size(25.dp)
                    )

                    CustomTextField(
                        value = reminderString,
                        onValueChange = { reminderString = it },
                        label = "Reminder",
                        placeholder = "Enter reminder time",
                        leadingIcon = Icons.Sharp.AddAlert,
                        enabled = !isReminderLinked,
                        modifier = Modifier.weight(1f)
                    )
                }

                // Duration and End Time Side by Side
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    LaunchedEffect (durationString){
                        if (durationString.isNotEmpty()) {
                            try {
                                endTimeString = dateTimeToString(startTime.plusMinutes(durationString.toLong()))
                            } catch (e: NumberFormatException) {
                                Toast.makeText(context, "Invalid duration format", Toast.LENGTH_SHORT).show()
                            }
                        }

                    }

                    CustomTextField(
                        value = durationString,
                        onValueChange = { durationString = it },
                        label = "Duration",
                        placeholder = "Enter duration",
                        leadingIcon = Icons.Sharp.Timer,
                        keyboardOptions = KeyboardOptions.Default.copy(keyboardType = KeyboardType.Number),
                        modifier = Modifier.weight(1f),
                    )

                    CustomTextField(
                        value = endTimeString,
                        onValueChange = { endTimeString = it },
                        label = "End Time",
                        placeholder = "Enter End Time",
                        leadingIconResId = R.drawable.arrowrighttoleft,
                        modifier = Modifier.weight(1f),
                    )
                }

                CustomTextField(
                    value = notes,
                    onValueChange = { notes = it },
                    label = "Notes",
                    placeholder = "Add Notes",
                    leadingIcon = Icons.Default.Link,
                    modifier = Modifier
                        .fillMaxWidth(),
                    singleLine = false
                )

                TaskTypeDropdown(taskType, onTaskTypeSelected = { newType -> taskType = newType })

                CustomTextField(
                    value = idFormatted,
                    onValueChange = { },
                    label = "ID (Only for dev)",
                    placeholder = "Internal purposes",
                    enabled = false,
                    modifier = Modifier.fillMaxWidth(),
                )

                CustomTextField(
                    value = positionString,
                    onValueChange = {positionString = it},
                    label = "Position (Don't Change) (Only for dev)",
                    placeholder = "Internal purposes. Don't change.",
                    modifier = Modifier.fillMaxWidth(),
                    enabled = true
                )

                Row(
                    horizontalArrangement = Arrangement.SpaceBetween,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    // Cancel Button
                    Button(
                        modifier = Modifier
                            .padding(5.dp)
                            .size(120.dp, 50.dp),
                        shape = RoundedCornerShape(25.dp),

                        onClick = { onCancel() },
                        colors = ButtonDefaults.buttonColors(
                            LocalCustomColorsPalette.current.gray200,
                        )

                    ) {
                        Text("Cancel")
                    }

                    // Save Button
                    FloatingActionButton(
                        containerColor = MaterialTheme.colorScheme.primary,
                        modifier = Modifier
                            .padding(5.dp)
                            .size(120.dp, 50.dp),
                        elevation = FloatingActionButtonDefaults.elevation(10.dp),
                        onClick = {
                            Log.d("EditTaskScreen", "Save Button clicked...")
                            coroutineScope.launch {
                                try {
                                    startTime = strToDateTime(startTimeString)
                                    endTime = strToDateTime(endTimeString)
                                    reminder = strToDateTime(reminderString)
                                    duration = durationString.toInt()
                                    id = idFormatted.toInt()
                                    position = positionString.toInt()

                                } catch (e: Exception) {
                                    Log.e("EditTaskScreen", "Error: $e")
                                    Toast.makeText(context, "Error saving task: ${e.message}", Toast.LENGTH_LONG).show()
                                }

                                val updatedTask = task.copy(
                                    name = taskName,
                                    position = position,
                                    notes = notes,
                                    startTime = startTime,
                                    endTime = endTime,
                                    reminder = reminder,
                                    duration = duration,
                                    type = taskType
                                )

                                onConfirmTaskEdit(updatedTask)

                            } // End of Coroutine
                        }
                    ) {
                        Text("Save")
                    }
                }

            }
        }
    }
}


// Content from TaskDetailsDialog.kt
package com.app.routineturboa.ui.task.dialogs


@Composable
fun TaskDetailsDialog(
    task: TaskEntity,
    onDismiss: () -> Unit
) {
    AlertDialog(
        onDismissRequest = { onDismiss() },
        title = {
            Column(
                horizontalAlignment = Alignment.CenterHorizontally,
                modifier = Modifier.fillMaxWidth()
            ) {
                Icon(
                    imageVector = Icons.Default.Info,
                    contentDescription = "Task Info",
                    tint = MaterialTheme.colorScheme.primary,
                    modifier = Modifier.size(40.dp)
                )
                Spacer(modifier = Modifier.size(8.dp))
                Text(text = "Task Details", style = MaterialTheme.typography.titleLarge)
            }
        },
        text = {
            Column(
                verticalArrangement = Arrangement.spacedBy(8.dp),
                modifier = Modifier.padding(16.dp)
            ) {
                Text(text = "ID: ${task.id}", style = MaterialTheme.typography.bodyMedium)

                val startTimeString = dateTimeToString(task.startTime)
                Text(text = "Start Time: $startTimeString", style = MaterialTheme.typography.bodyMedium)

                val endTimeString = dateTimeToString(task.endTime)
                Text(text = "End Time: $endTimeString", style = MaterialTheme.typography.bodyMedium)

                Text(text = "Name: ${task.name}", style = MaterialTheme.typography.bodyMedium)

                if (task.notes.isNotBlank()) {
                    Text(text = "Notes: ${task.notes}", style = MaterialTheme.typography.bodyMedium)
                }

                Text(text = "Position: ${task.position}", style = MaterialTheme.typography.bodyMedium)

                Text(text = "Type: ${task.type}", style = MaterialTheme.typography.bodyMedium)

                val reminderString = dateTimeToString(task.reminder)
                Text(text = "Reminder: $reminderString", style = MaterialTheme.typography.bodyMedium)

                // Adding a divider for better visual separation
                HorizontalDivider(
                    modifier = Modifier.padding(vertical = 8.dp),
                    thickness = 1.dp,
                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f)
                )
            }
        },
        confirmButton = {
            Button(onClick = { onDismiss() }) {
                Text("Close")
            }
        }
    )
}


// Content from Converters.kt
package com.app.routineturboa.utils


object Converters {
    private val formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME

    @TypeConverter
    @JvmStatic
    fun fromLocalDateTime(value: LocalDateTime?): String? {
        return value?.format(formatter)
    }

    @TypeConverter
    @JvmStatic
    fun toLocalDateTime(value: String?): LocalDateTime? {
        return value?.let {
            LocalDateTime.parse(it, formatter)
        }
    }
}


// Content from demoTasks.kt
package com.app.routineturboa.utils


val demoTaskTwo = TaskEntity(
    position = 2,
    name = "Morning Ritual",
    notes = "",
    duration = 5,
    startTime = strToDateTime("06:00 AM"),
    endTime = strToDateTime("06:05 AM"),
    reminder = strToDateTime("06:00 AM"),
    type = "default"
)

val demoTaskThree = TaskEntity(
    position = 3,
    name = "Freshen up",
    notes = "",
    duration = 20,
    startTime = strToDateTime("06:05 AM"),
    endTime = strToDateTime("06:25 AM"),
    reminder = strToDateTime("06:05 AM"),
    type = "default"
)

val demoTaskFour = TaskEntity(
    position = 4,
    name = "Ready for running",
    notes = "",
    duration = 10,
    startTime = strToDateTime("06:25 AM"),
    endTime = strToDateTime("06:35 AM"),
    reminder = strToDateTime("06:25 AM"),
    type = "default"
)

val demoTaskFive = TaskEntity(
    position = 5,
    name = "Running",
    notes = "",
    duration = 40,
    startTime = strToDateTime("06:35 AM"),
    endTime = strToDateTime("07:15 AM"),
    reminder = strToDateTime("06:35 AM"),
    type = "default"
)

val demoTaskSix = TaskEntity(
    position = 6,
    name = "Freshen up",
    notes = "",
    duration = 15,
    startTime = strToDateTime("07:15 AM"),
    endTime = strToDateTime("07:30 AM"),
    reminder = strToDateTime("07:15 AM"),
    type = "default"
)

val demoTaskSeven = TaskEntity(
    position = 7,
    name = "Check emails and stuff",
    notes = "",
    duration = 30,
    startTime = strToDateTime("07:30 AM"),
    endTime = strToDateTime("08:00 AM"),
    reminder = strToDateTime("07:30 AM"),
    type = "default"
)

val demoTaskEight = TaskEntity(
    position = 8,
    name = "Work",
    notes = "",
    duration = 90,
    startTime = strToDateTime("08:00 AM"),
    endTime = strToDateTime("09:30 AM"),
    reminder = strToDateTime("08:00 AM"),
    type = "default"
)

val demoTaskNine = TaskEntity(
    position = 9,
    name = "Breakfast",
    notes = "",
    duration = 30,
    startTime = strToDateTime("09:30 AM"),
    endTime = strToDateTime("10:00 AM"),
    reminder = strToDateTime("09:30 AM"),
    type = "default"
)

val demoTaskTen = TaskEntity(
    position = 10,
    name = "Work",
    notes = "",
    duration = 90,
    startTime = strToDateTime("10:00 AM"),
    endTime = strToDateTime("11:30 AM"),
    reminder = strToDateTime("10:00 AM"),
    type = "default"
)

val demoTaskEleven = TaskEntity(
    position = 11,
    name = "Break",
    notes = "",
    duration = 30,
    startTime = strToDateTime("11:30 AM"),
    endTime = strToDateTime("12:00 PM"),
    reminder = strToDateTime("11:30 AM"),
    type = "default"
)

val demoTaskTwelve = TaskEntity(
    position = 12,
    name = "Work",
    notes = "",
    duration = 90,
    startTime = strToDateTime("12:00 PM"),
    endTime = strToDateTime("01:30 PM"),
    reminder = strToDateTime("12:00 PM"),
    type = "default"
)

val demoTaskThirteen = TaskEntity(
    position = 13,
    name = "Break",
    notes = "",
    duration = 30,
    startTime = strToDateTime("01:30 PM"),
    endTime = strToDateTime("02:00 PM"),
    reminder = strToDateTime("01:30 PM"),
    type = "default"
)

val demoTaskFourteen = TaskEntity(
    position = 14,
    name = "Lunch and Rest",
    notes = "",
    duration = 60,
    startTime = strToDateTime("02:00 PM"),
    endTime = strToDateTime("03:00 PM"),
    reminder = strToDateTime("02:00 PM"),
    type = "default"
)

val demoTaskFifteen = TaskEntity(
    position = 15,
    name = "Creative Work",
    notes = "",
    duration = 60,
    startTime = strToDateTime("03:00 PM"),
    endTime = strToDateTime("04:00 PM"),
    reminder = strToDateTime("03:00 PM"),
    type = "default"
)

val demoTaskSixteen = TaskEntity(
    position = 16,
    name = "Work",
    notes = "",
    duration = 90,
    startTime = strToDateTime("04:00 PM"),
    endTime = strToDateTime("05:30 PM"),
    reminder = strToDateTime("04:00 PM"),
    type = "default"
)

val demoTaskSeventeen = TaskEntity(
    position = 17,
    name = "Tea",
    notes = "",
    duration = 30,
    startTime = strToDateTime("05:30 PM"),
    endTime = strToDateTime("06:00 PM"),
    reminder = strToDateTime("05:30 PM"),
    type = "default"
)

val demoTaskEighteen = TaskEntity(
    position = 18,
    name = "Leisure",
    notes = "",
    duration = 60,
    startTime = strToDateTime("06:00 PM"),
    endTime = strToDateTime("07:00 PM"),
    reminder = strToDateTime("06:00 PM"),
    type = "default"
)

val demoTaskNineteen = TaskEntity(
    position = 19,
    name = "Work",
    notes = "",
    duration = 120,
    startTime = strToDateTime("07:00 PM"),
    endTime = strToDateTime("09:00 PM"),
    reminder = strToDateTime("07:00 PM"),
    type = "default"
)

val demoTaskTwenty = TaskEntity(
    position = 20,
    name = "Dinner",
    notes = "",
    duration = 30,
    startTime = strToDateTime("09:00 PM"),
    endTime = strToDateTime("09:30 PM"),
    reminder = strToDateTime("09:00 PM"),
    type = "default"
)

val demoTaskTwentyOne = TaskEntity(
    position = 21,
    name = "Night Rituals",
    notes = "",
    duration = 30,
    startTime = strToDateTime("09:30 PM"),
    endTime = strToDateTime("10:00 PM"),
    reminder = strToDateTime("09:30 PM"),
    type = "default"
)

val demoTaskTwentyTwo = TaskEntity(
    position = 22,
    name = "Read and Sleep",
    notes = "",
    duration = 30,
    startTime = strToDateTime("10:00 PM"),
    endTime = strToDateTime("10:30 PM"),
    reminder = strToDateTime("10:00 PM"),
    type = "default"
)


// Content from NotificationPermissionHandler.kt
package com.app.routineturboa.utils


/**
 * @Name: NotificationPermissionHandler
 * @Description:
 * Companion Object: Contains all the necessary methods for handling notification permissions.
 * - initialize method sets up the requestPermissionLauncher with the activity and state.
 * - requestNotificationPermission method requests the notification permission.
 * - isNotificationPermissionGiven method checks if the notification permission is granted.
 *
 * Initialization: The initialize method sets up the ActivityResultLauncher that handles the permission request result.
 *
 */

class NotificationPermissionHandler {

    companion object {
        private const val TAG = "NotificationPermissionHandler"

        private lateinit var requestPermissionLauncher: ActivityResultLauncher<String>

        @RequiresApi(Build.VERSION_CODES.S)
        fun initialize(activity: ComponentActivity, isPermissionGranted: MutableState<Boolean>) {
            requestPermissionLauncher = activity.registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean ->
                isPermissionGranted.value = isGranted
                if (isGranted) {
                    Log.d(TAG, "Notification permission granted")
                } else {
                    Log.d(TAG, "Notification permission denied")
                }
            }
        }

        @RequiresApi(Build.VERSION_CODES.S)
        fun requestNotificationPermission() {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)
            } else {
                Log.d(TAG, "Android version < 33, no notification permission request needed.")
            }
        }

        fun isNotificationPermissionGiven(context: Context): Boolean {
            return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                ContextCompat.checkSelfPermission(
                    context,
                    Manifest.permission.POST_NOTIFICATIONS
                ) == PackageManager.PERMISSION_GRANTED
            } else {
                true // Permission is automatically granted on older Android versions
            }
        }
    }
}



// Content from SineEasing.kt
package com.app.routineturboa.utils


object SineEasing : Easing {
    override fun transform(fraction: Float): Float {
        return sin(fraction * PI.toFloat() / 2)
    }
}

// Content from TimeUtils.kt
package com.app.routineturboa.utils


object TimeUtils {

    val possibleFormats = listOf(
        DateTimeFormatter.ofPattern("h:mm a", Locale.US),
        DateTimeFormatter.ofPattern("hh:mm a", Locale.US),
        DateTimeFormatter.ofPattern("H:mm", Locale.US),
        DateTimeFormatter.ofPattern("HH:mm", Locale.US)
    )

    /**
     * String (various time formats) to LocalDateTime
     * A default date is added to input string
     */
    fun strToDateTime(timeString: String): LocalDateTime {
        val trimmedTimeString = timeString.trim().uppercase()

        for (formatter in possibleFormats) {
            try {
                val localTime = LocalTime.parse(trimmedTimeString, formatter)
                return LocalDateTime.of(LocalDate.now(), localTime)
            } catch (e: DateTimeParseException) {
                Log.e("TimeUtils", "Error parsing time string: $timeString")
            }
        }

        // If we've exhausted all formatters without success, throw an exception
        throw IllegalArgumentException("Error parsing time string: $timeString")
    }

    fun dateTimeToString(dateTime: LocalDateTime): String {
        val dateTimeFormatter = DateTimeFormatter.ofPattern("hh:mm a")
        return dateTimeFormatter.format(dateTime)
    }

    private val inputFormat: SimpleDateFormat
        get() = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())
    private val outputFormat: SimpleDateFormat
        get() = SimpleDateFormat("hh:mm a", Locale.getDefault())
    private val timeOnlyFormat: SimpleDateFormat
        get() = SimpleDateFormat("HH:mm:ss", Locale.getDefault())  // Ensure the time format includes seconds

    fun isValidTimeFormat(time: String): Boolean {
        return try {
            outputFormat.parse(time)
            true
        } catch (e: ParseException) {
            false
        }
    }

    fun addDurationToTime(startTime: String, duration: Int): String {
        val calendar = Calendar.getInstance()
        val date = try {
            inputFormat.parse(startTime)
        } catch (e: ParseException) {
            outputFormat.parse(startTime)
        }
        calendar.time = date!!
        calendar.add(Calendar.MINUTE, duration)
        return outputFormat.format(calendar.time)
    }

}


// Content from TasksViewModel.kt
package com.app.routineturboa.viewmodel


const val TAG = "TasksViewModel"

class TasksViewModel(private val repository: RoutineRepository) : ViewModel() {

    val tasks: StateFlow<List<TaskEntity>> = repository.getAllTasks()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

    // Function to fetch MainTasks from the repository
    fun getMainTasks(): Flow<List<TaskEntity>> {
        return repository.getTasksByType("MainTask")
    }

    fun updateTaskAndAdjustNext(initialEditedTask: TaskEntity) {
        Log.d(TAG, "Updating '${initialEditedTask.name}' task and its next task.")

        viewModelScope.launch {
            try {
                // Data preparations

                val taskBelow = fetchNextTask(initialEditedTask)
                if (taskBelow != null) {
                    Log.d(TAG, "Task below to update: ${taskBelow.name}")

                    val startTimeTaskBelow = initialEditedTask.endTime
                    val durationTaskBelow = Duration.between(startTimeTaskBelow, taskBelow.endTime)
                    val durationTaskBelowInt = durationTaskBelow.toMinutes().toInt()

                    // Create a new task entity with the updated duration and start time
                    val taskWithUpdatesForBelow = taskBelow.copy(
                        duration = durationTaskBelowInt,
                        startTime = startTimeTaskBelow
                    )

                    Log.d(TAG, "old duration: ${taskBelow.duration}, new duration: ${taskWithUpdatesForBelow.duration}, " +
                            "old startTime: ${taskBelow.startTime}, new start time: ${taskWithUpdatesForBelow.startTime}")

                    // Run the transaction with both updates
                    repository.runAsTransaction {
                        repository.updateTask(initialEditedTask)
                        repository.updateTask(taskWithUpdatesForBelow)
                    }

                } else {
                    Log.d(TAG, "No task below to update. Updating only the edited task.")

                    // Run the transaction with only the update to taskToUpdate
                    repository.runAsTransaction {
                        repository.updateTask(initialEditedTask)
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error updating tasks", e)
            }
        }
    }

    /**
     * @name beginNewTaskOperations
     * The begins the new task operations. The order of operations matter.
     *
     * @param clickedTask
     * @param newTask
     *
     * ## Purpose
     * This function manages the process of inserting a new task into an ordered list of tasks, ensuring proper positioning and duration management of affected tasks.
     *
     * ## Parameters
     * - `clickedTask: TaskEntity`: The task after which the new task will be inserted.
     * - `newTask: TaskEntity`: The new task to be inserted.
     *
     * ## Return Value
     * - `Result<Boolean>`: A Result object containing a Boolean.
     *   - Success (true) indicates all operations completed successfully.
     *   - Failure contains an Exception with details about what went wrong.
     *
     * ## Process Flow
     *
     * ### 1. Duration Validation
     * - **Timing**: Occurs before any database changes.
     * - **Purpose**: Ensures the new task's duration is valid in relation to the task it will precede.
     * - **Steps**:
     *   a. Retrieves the task currently below the `clickedTask` (referred to as `taskBelowToBeShifted`).
     *   b. Compares `newTask.duration` with `taskBelowToBeShifted.duration`.
     *   c. If `newTask.duration` is greater than or equal to `taskBelowToBeShifted.duration`, the operation fails.
     * - **Failure Handling**: Returns a `Result.failure` with an appropriate error message.
     *
     * ### 2. Update Positions
     *      * - **Timing**: Occurs after all other operations are complete.
     *      * - **Purpose**: Ensures all tasks below the newly inserted task have correct positions.
     *      * - **Steps**:
     *      *   a. Calls `updateTaskPositions(newTask)` to adjust positions of all tasks below the new task.
     *      *   b. Increments the position of each affected task by 1.
     *
     * ### 3. New Task Insertion
     * - **Timing**: Occurs immediately after successful duration validation.
     * - **Purpose**: Adds the new task to the database.
     * - **Note**: The `newTask` already has its position set (clickedTask.position + 1).
     *
     * ### 4. Update Duration of Shifted Task
     * - **Timing**: Occurs right after the new task insertion.
     * - **Purpose**: Adjusts the duration of the task that is now below the newly inserted task.
     * - **Steps**:
     *   a. Calculates the new duration: `taskBelowToBeShifted.duration - newTask.duration`
     *   b. Updates `taskBelowToBeShifted` with this new duration.
     * - **Note**: This task is referred to as "now-shifted" because the new task has been inserted above it.
     *
     *
     * ## Important Considerations
     * 1. **Transaction Management**: The entire process is wrapped in a database transaction. This ensures that either all operations succeed, or none are applied if any step fails.
     *
     * 2. **Error Handling**:
     *    - Validation errors (e.g., invalid duration) and Unexpected exceptions result in a `Result.failure` return.
     *
     * 3. **Positional Awareness**: The function assumes that `newTask.position` is already set correctly (clickedTask.position + 1) before being passed to this function.
     *
     * 6. **Task Relationships**:
     *    - `clickedTask`: The task after which the new task will be inserted.
     *    - `newTask`: The task being inserted.
     *    - `taskBelowToBeShifted`: Initially the task below `clickedTask`, ends up below `newTask` after insertion.
     *
     * ## Usage
     * This function should be called when a user action triggers the insertion of a new task at a specific position in the task list. It handles all necessary validations and updates to maintain the integrity of the task list structure.
     */
    fun beginNewTaskOperations(clickedTask: TaskEntity, newTask: TaskEntity): Result<Boolean> {
        return runBlocking {
            try {
                repository.runAsTransaction {
                    Log.d(TAG, "----Starting new task operations-----")

                    val taskBelowToBeShifted = fetchNextTask(clickedTask)
                        ?: return@runAsTransaction Result.failure(Exception("Task below clicked task not found"))

                    Log.d(TAG, " **** Clicked task: '${clickedTask.name}', " +
                            "New task: '${newTask.name}'," +
                            "Task Below: '${taskBelowToBeShifted.name}'")

                    // 1. Validate duration
                    Log.d(TAG, " **** 1st Step) Validating duration...")
                    val taskBelowToBeShiftedDuration = taskBelowToBeShifted.duration

                    if (newTask.duration >= taskBelowToBeShiftedDuration )  {
                        Log.e(TAG, "Invalid duration. New Task duration: ${newTask.duration}, " +
                                "Task Below Duration: $taskBelowToBeShiftedDuration")
                        return@runAsTransaction Result.failure(Exception("Invalid new task duration"))
                    }

                    // 2. Update Positions of all the tasks below the new Task
                    Log.d(TAG, " **** 2nd Step) Updating positions...")
                    incrementTasksBelow(clickedTask)

                    // 3. Inserting new task...
                    Log.d(TAG, " **** 3rd Step) Inserting new task...")
                    repository.insertTask(newTask)

                    // 4. Updating duration and startTime of shifted task
                    Log.d(TAG, " **** 4th Step) Updating duration and startTime of shifted task...")
                    val updatedDuration = taskBelowToBeShiftedDuration - newTask.duration
                    val updatedStartTime = newTask.endTime

                    val taskBelowNowShifted = taskBelowToBeShifted.copy()

                    Log.d(TAG, "taskBelow-NOW-Shifted Position: ${taskBelowNowShifted.position}" +
                            " taskBelow-To-Be-Shifted Position: ${taskBelowToBeShifted.position}")

                    // Exclude the last task from the update
                    if (!isTaskLast(taskBelowNowShifted)) {
                        Log.d(TAG, "Task Below is not the last task. Updating with new duration, start Time, and new position.")
                        val taskBelowNowShiftedUpdated = taskBelowToBeShifted.copy(
                            duration = updatedDuration,
                            startTime = updatedStartTime,
                            position = newTask.position + 1
                        )
                        updateTaskAndAdjustNext(taskBelowNowShiftedUpdated)
                    } else {
                        Log.d(TAG, "Task Below is the last task. Updating with new duration and start Time.")
                        val taskBelowNowShiftedUpdated = taskBelowToBeShifted.copy(
                            duration = updatedDuration,
                            startTime = updatedStartTime
                        )
                        updateTaskAndAdjustNext(taskBelowNowShiftedUpdated)
                    }

                    Result.success(true)
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error inserting task", e)
                Result.failure(e)
            }
        }
    }

    private fun incrementTasksBelow(referenceTask: TaskEntity?) {

        if (referenceTask == null) {
            Log.e(TAG, "incrementTasksBelow: anchorTask is null")
            return
        }

        val taskBelowReferenceTask = fetchNextTask(referenceTask)

        if (taskBelowReferenceTask != null ){
            if (isTaskLast(taskBelowReferenceTask)) {
                Log.e(TAG, "incrementTasksBelow: taskBelowReferenceTask is last task. Skipping updating positions.")
                return
            }
        }

        viewModelScope.launch {
            Log.d(TAG, "Updating task positions below clickedTask: ${referenceTask.name}")

            val currentTasks = tasks.value
            // Find the index of the reference task
            val referenceTaskIndex = currentTasks.indexOfFirst { it.id == referenceTask.id }

            // Exclude the last task from the update
            val listOfTasksToUpdate = currentTasks
                .drop(referenceTaskIndex + 1)  // Skip tasks up to and including the reference task
                .dropLast(1)  // Remove the last task

            Log.d(TAG, "tasks to update - ${listOfTasksToUpdate.map { "Name:${it.name}, Position:${it.position}"}}")

            var newPosition = referenceTask.position + 1

            val tasksWithNewPositions = mutableListOf<TaskEntity>()

            for (task in listOfTasksToUpdate) {
                newPosition++
                val taskWithNewPosition = task.copy(position = newPosition)
                Log.d(TAG, "Updating task '${task.name}' position from ${task.position} to ${taskWithNewPosition.position}")
                tasksWithNewPositions.add(taskWithNewPosition)
            }

            if (tasksWithNewPositions.isNotEmpty()) {
                // Update all affected tasks in a single transaction
                val updateResult = repository.updateTasksWithNewPositions(tasksWithNewPositions)
                Log.d(TAG, "Update result: $updateResult")
            } else {
                Log.d(TAG, "No tasks to update")
            }
        }
    }

    init {
        viewModelScope.launch {
            repository.initializeDefaultTasks()
        }
    }

    fun fetchNextTask(baseTask: TaskEntity): TaskEntity? {
        Log.d(TAG, "Getting task below '${baseTask.name}' task...")

        if (isTaskLast(baseTask)){
            Log.d(TAG, "baseTask is last task. Returning null.")
            return null
        }

        val currentTasks = tasks.value
        val baseTaskIndex = currentTasks.indexOfFirst { it.id == baseTask.id }

        return if (baseTaskIndex != -1 && baseTaskIndex < currentTasks.size - 1) {
            val nextTask = currentTasks[baseTaskIndex + 1]
            Log.d(TAG, "Next Task: ${nextTask.name}")
            nextTask
        } else {
            Log.d(TAG, "No task found below or clicked task is not in the list.")
            null
        }
    }

    private fun fetchLastTask(): TaskEntity? {
        val tasks = tasks.value

        if (tasks.isEmpty()) {
            Log.e(TAG, "Task list is empty")
            return null
        }

        val lastTask = tasks.maxByOrNull { it.position }
        if (lastTask == null) {
            Log.e(TAG, "Failed to find last task by position")
            return null
        }

        // Check if the end time is 23:59
        val expectedEndTime = LocalTime.of(23, 59)
        if (lastTask.endTime.toLocalTime() != expectedEndTime) {
            Log.e(TAG, "Last task (${lastTask.name}) end time is not 23:59. Actual end time: ${lastTask.endTime}")
        }
        val expectedTaskID = -2
        if (lastTask.id != expectedTaskID) {
            Log.e(TAG, "Last task (${lastTask.name}) has an unexpected ID. Expected: $expectedTaskID, Actual: ${lastTask.id}")
        }

        return lastTask
    }

    fun isTaskFirst(task: TaskEntity): Boolean {
        val tasks = tasks.value

        if (tasks.isEmpty()) {
            Log.d(TAG, "Task list is empty")
            return false
        }

        val firstTask = tasks.minByOrNull { it.position }
        if (firstTask == null) {
            Log.e(TAG, "Failed to find first task by position")
            return false
        }

        if (task.position != 1) {
            return false
        }

        // Check if the start time is 00:01
        val expectedStartTime = LocalTime.of(0, 1)
        if (task.startTime.toLocalTime() != expectedStartTime) {
            Log.e(TAG, "First task (${task.name}) start time is not 00:01. Actual start time: ${task.startTime.toLocalTime()}")
        }

        // Check if the ID is -1
        val expectedTaskID = -1
        if (task.id != expectedTaskID) {
            Log.e(TAG, "First task (${task.name}) has an unexpected ID. Expected: $expectedTaskID, Actual: ${task.id}")
        }

        return true
    }

    fun isTaskLast(task: TaskEntity): Boolean {
        val lastTask = fetchLastTask()
        if (lastTask == null) {
            Log.e(TAG, "Failed to get last task")
            return false
        }

        if (task.position != lastTask.position) {
            return false
        }

        // Check if the end time is 23:59
        val expectedEndTime = LocalTime.of(23, 59)
        if (task.endTime.toLocalTime() != expectedEndTime) {
            Log.e(TAG, "Last task (${task.name}) end time is not 23:59. Actual end time: ${task.endTime.toLocalTime()}")
        }

        // Check if the ID is -2
        val expectedTaskID = -2
        if (task.id != expectedTaskID) {
            Log.e(TAG, "Last task (${task.name}) has an unexpected ID. Expected: $expectedTaskID, Actual: ${task.id}")
        }

        return true
    }

    fun deleteTask(task: TaskEntity) {
        viewModelScope.launch {
            repository.deleteTask(task)
        }
    }

    fun insertDemoTasks() {
        viewModelScope.launch {
            repository.initializeDemoTasks()
        }
    }
}


// Content from TaskViewModelFactory.kt


class TaskViewModelFactory(private val repository: RoutineRepository) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(TasksViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return TasksViewModel(repository) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

