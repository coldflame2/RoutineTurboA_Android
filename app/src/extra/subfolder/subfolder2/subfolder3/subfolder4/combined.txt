
// Content from MainActivity.kt
package com.app.routineturboa



class MainActivity : ComponentActivity() {
    private val tag = "MainActivity"
    private lateinit var isNotificationPermissionGiven: MutableState<Boolean>
    private lateinit var showPermissionDialog: MutableState<Boolean>
    private lateinit var reminderManager: ReminderManager

    @RequiresApi(Build.VERSION_CODES.S)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Log.d(tag, "onCreate for MainActivity")

        // Set to true to make system windows visible
        WindowCompat.setDecorFitsSystemWindows(window, true)

        // Get TaskDao from the Room database
        val taskDao = RoutineDatabase.getDatabase().taskDao()

        // Initialize the repository with TaskDao
        val dataRepository = DataRepository(taskDao)

        // Pass the repository to ReminderManager
        reminderManager = ReminderManager(this, dataRepository)

        // Initialize the state variables for Notifications permissions
        isNotificationPermissionGiven = mutableStateOf(
            NotificationPermissionHandler.isNotificationPermissionGiven(this)
        )
        showPermissionDialog = mutableStateOf(!isNotificationPermissionGiven.value)

        // Register the ActivityResultLauncher
        NotificationPermissionHandler.initialize(this, isNotificationPermissionGiven)

        setContent {
            RoutineTurboATheme {
                window.statusBarColor = MaterialTheme.colorScheme.primary.toArgb()
                window.navigationBarColor = MaterialTheme.colorScheme.primary.toArgb()

                // Initialize the TasksViewModel
                val tasksVM: TasksViewModel = viewModel(factory = TasksViewModelFactory())

                // Provide ReminderManager to the composable hierarchy
                CompositionLocalProvider(LocalReminderManager provides reminderManager) {
                    MainScreen(
                        tasksVM = tasksVM
                    )
                }

                // Show AlertDialog for granting permissions
                if (showPermissionDialog.value) {
                    Log.d(tag, "Permissions not given. Showing dialog for granting permissions.")

                    AlertDialog(
                        title = { Text("Notification Permission") },
                        onDismissRequest = { showPermissionDialog.value = false },
                        text = {
                            Text (
                                text = "This app needs notification permission to send you reminders." +
                                    "Would you like to grant this permission?"
                            )
                        },
                        dismissButton = {
                            Button(onClick = { showPermissionDialog.value = false }) {
                                Text("Not Now")
                            }
                        },
                        confirmButton = {
                            Button(onClick = {
                                showPermissionDialog.value = false
                                NotificationPermissionHandler.requestNotificationPermission()
                            }) {
                                Text("Grant Permission")
                            }
                        }
                    )
                }
            }
        }
    }
}


// Content from RoutineTurboApp.kt
package com.app.routineturboa


class RoutineTurboApp : Application() {
    private val applicationScope = CoroutineScope(SupervisorJob() + Dispatchers.Main)
    lateinit var msalAuthManager: MsalAuthManager

    companion object {
        lateinit var instance: RoutineTurboApp
            private set
    }

    override fun onCreate() {
        super.onCreate()

        Log.d("MyApplication", "     ***** STARTING APPLICATION ****** ")

        instance = this

        msalAuthManager = MsalAuthManager.getInstance(this)

        applicationScope.launch {
            Log.d("MyApplication", "Calling MsalAuthManager.initialize from MyApplication")
            msalAuthManager.initialize()
        }

        createNotificationChannel()
    }

    private fun createNotificationChannel() {
        val channelId = "tasks_channel_id"
        val channelName = "Tasks Reminders"
        val importance = NotificationManager.IMPORTANCE_HIGH

        val channel = NotificationChannel(channelId, channelName, importance)
        channel.description = "Channel for tasks reminders"

        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        notificationManager.createNotificationChannel(channel)
    }
}

// Content from RoutineDatabase.kt
package com.app.routineturboa.data.local


@Database(entities = [TaskEntity::class], version = 1, exportSchema = false)
@TypeConverters(Converters::class)
abstract class RoutineDatabase : RoomDatabase() {

    abstract fun taskDao(): TaskDao

    companion object {
        private const val TAG = "RoutineDatabase"

        @Volatile
        private var INSTANCE: RoutineDatabase? = null

        fun getDatabase(): RoutineDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    RoutineTurboApp.instance.applicationContext,
                    RoutineDatabase::class.java,
                    "routine_database"
                )
                .build()
                INSTANCE = instance
                Log.d(TAG, "Database initialized.")
                instance
            }
        }
    }
}

// Content from TaskDao.kt
package com.app.routineturboa.data.local


const val tag = "TaskDao"

@Dao
interface TaskDao {

    @Transaction
    suspend fun runTaskTransaction(block: suspend () -> Unit) {
        return block()
    }

    @Query("SELECT * FROM tasks_table ORDER BY position ASC")
    fun getAllTasks(): Flow<List<TaskEntity>>

    @Query("SELECT * FROM tasks_table WHERE position = (SELECT MAX(position) FROM tasks_table)")
    suspend fun getTaskWithMaxPosition(): TaskEntity?

    // Query to get tasks by type
    @Query("SELECT * FROM tasks_table WHERE type = :type")
    fun getTasksByType(type: String): Flow<List<TaskEntity>>

    @Insert(onConflict = OnConflictStrategy.ABORT)
    suspend fun insertTask(task: TaskEntity): Long

    @Query("SELECT COUNT(*) FROM tasks_table")
    suspend fun getTasksCount(): Int

    @Update
    suspend fun updateTask(task: TaskEntity)

    @Transaction
    suspend fun updateTasksWithNewPositions(tasks: List<TaskEntity>) {
        tasks.forEach { task ->
            Log.d(tag, "Updating task '${task.name}'. task ID: ${task.id}, position: ${task.position}" )
            updateTaskPosition(task.id, task.position)
        }
    }

    @Transaction
    suspend fun updateTasksWithNewIds(tasks: List<TaskEntity>) {
        tasks.forEach { task ->
            Log.d(tag, "Updating task '${task.name}'. task ID: ${task.id}" )
            updateTaskId(task.id)
        }
    }

    @Query("UPDATE tasks_table SET id = :newId")
    suspend fun updateTaskId(newId: Int)

    @Query("UPDATE tasks_table SET position = :newPosition WHERE id = :taskId")
    suspend fun updateTaskPosition(taskId: Int, newPosition: Int)

    @Update
    suspend fun updateAllTasks(tasks: List<TaskEntity>)

    @Delete
    suspend fun deleteTask(task: TaskEntity)

    @Query("SELECT * FROM tasks_table WHERE id = :taskId")
    suspend fun getTaskById(taskId: Int): TaskEntity?

    @Query("SELECT * FROM tasks_table WHERE id = (SELECT MIN(id) FROM tasks_table)")
    suspend fun getFirstTask(): TaskEntity?

    @Query("SELECT * FROM tasks_table WHERE id = (SELECT MAX(id) FROM tasks_table)")
    suspend fun getLastTask(): TaskEntity?

    @Transaction
    suspend fun safeInsertTask(task: TaskEntity): Long {
        return try {
            insertTask(task)  // returns new rowID
        } catch (e: SQLiteConstraintException) {
            Log.e("TaskDao", "Insertion failed: ${e.message}")
            -1L  // Return -1 to indicate failure
        }
    }

    @Query("DELETE FROM tasks_table")
    suspend fun deleteAllTasks() // Deletes all tasks from the tasks table

    @Query("UPDATE tasks_table SET position = position + 1 WHERE position >= :position")
    suspend fun incrementPositionsBelow(position: Int)
}

// Content from TaskEntity.kt
package com.app.routineturboa.data.local


@Entity(tableName = "tasks_table")
@TypeConverters(Converters::class)
data class TaskEntity(
    @PrimaryKey(autoGenerate = true) val id: Int = 0,
    val name: String,
    val notes: String = "",
    val duration: Int,
    val startTime: LocalDateTime,
    val endTime: LocalDateTime,
    val reminder: LocalDateTime,
    val type: String,
    val position: Int,
    val mainTaskId: Int? = null
)


// Content from MainScreen.kt
package com.app.routineturboa.ui.main


@RequiresApi(Build.VERSION_CODES.S)
@Composable
fun MainScreen(tasksVM: TasksViewModel) {
    Log.d("MainScreen", "MainScreen starts...")

    // Access ReminderManager using CompositionLocal LocalReminderManager
    val reminderManager = LocalReminderManager.current

    val tasks by tasksVM.tasks.collectAsState()
    val tasksUiState by tasksVM.tasksUiState.collectAsState()

    val taskEventsToFunctions = TaskEventsToFunctions(
        onAnyTaskClick = tasksVM::onAnyTaskClick,
        onAnyTaskLongPress = tasksVM::onAnyTaskLongPress,
        onQuickEditClick = tasksVM::onQuickEditClick,
        onFullEditClick = tasksVM::onFullEditTask,
        onAddNewClick = tasksVM::onAddNewClick,
        onNewTaskSaveClick = tasksVM::onNewTaskSaveClick,
        onDeleteClick = tasksVM::onDeleteTask,
        onCancelClick = tasksVM::onCancelEdit,
        onConfirmEdit = tasksVM::onConfirmEdit,
        onShowTaskDetails = tasksVM::onShowTaskDetails,
    )

    val drawerState = rememberDrawerState(DrawerValue.Closed)

    ModalNavigationDrawer(
        // Rest of the UI color on drawer open
        scrimColor = MaterialTheme.colorScheme.primary.copy(alpha = 0.2f),
        drawerState = drawerState,
        drawerContent = { MainDrawer(drawerState, tasksVM, reminderManager) },
    ) {
        Scaffold(
            topBar = { MainTopBar(drawerState) },
            bottomBar = { MainBottomBar(taskEventsToFunctions.onAddNewClick) }
        ) { paddingValues ->  // These paddingValues are applied along the edges inside a box.
            TasksLazyColumn(
                paddingValues = paddingValues,
                tasks = tasks,
                tasksUiState = tasksUiState,
                taskEventsToFunctions = taskEventsToFunctions
            )
        }
    }
}

// Content from TasksLazyColumn.kt
package com.app.routineturboa.ui.main


@RequiresApi(Build.VERSION_CODES.S)
@Composable
// Usage: MainScreen
fun TasksLazyColumn(
    paddingValues: PaddingValues, // auto-calculated by Scaffold
    tasks:  List<TaskEntity>,
    tasksUiState: TasksUiState,
    taskEventsToFunctions: TaskEventsToFunctions
) {
    val tag = "TasksLazyColumn"
    val context = LocalContext.current
    var showLoadingIndicator by remember { mutableStateOf(true) }

    val mainTasks by remember(tasks) { mutableStateOf(tasks.filter { it.type == TaskTypes.MAIN }) }

    LazyColumn(
        modifier = Modifier.padding(paddingValues),  // Use paddingValues here
        contentPadding = PaddingValues(0.dp, 0.dp, 15.dp, 0.dp),
        verticalArrangement = Arrangement.spacedBy(2.dp)
    ) {
        if (!showLoadingIndicator && tasks.isNotEmpty()) {
            items(tasks,
                key = { task -> task.id }
            ) { task ->
                // Pass the necessary state and event handlers to ParentTaskItem
                ParentTaskItem(
                    task = task,
                    mainTasks = mainTasks,
                    tasksUiState = tasksUiState,
                    taskEventsToFunctions = taskEventsToFunctions,
                )
            }

        // Show indicator if empty tasks or showLoadingIndicator
        } else {
            items(8) { EmptyTaskCardPlaceholder() }
        }  // end of if-else in Lazy Column
    }  // end of Lazy Column

    // AddTaskDialog (Inside the parent Box)
    if (tasksUiState.isAddingNew && tasksUiState.clickedTaskId != null) {
        val clickedTask = tasks.find { it.id == tasksUiState.clickedTaskId }
        val taskBelowClickedTask = tasks.find {it.id == tasksUiState.taskBelowClickedTaskId}

        val boxColor = Color.Black.copy(alpha = 0.3f)

        Box(modifier = Modifier.background(boxColor)) {
            if (clickedTask != null){
                AddTaskDialog(
                    mainTasks = mainTasks,
                    clickedTask = clickedTask,
                    taskBelowClickedTask = taskBelowClickedTask,
                    onCancel = { taskEventsToFunctions.onCancelClick() },
                    onAddClick = { newTaskFormData ->
                        taskEventsToFunctions.onNewTaskSaveClick(newTaskFormData)
                    },
                )
            } else {
                Toast.makeText(
                    context,"Select a task first", Toast.LENGTH_SHORT).show()
            }
        }
    }

    // Show loading indicator at start (Temporary effect)
    LaunchedEffect(tasks) {
        delay(50)
        showLoadingIndicator = false
    }

}

// Content from BottomNavBar.kt
package com.app.routineturboa.ui.scaffold


@Composable
fun MainBottomBar(
    onAddNewClick: () -> Unit,  // For setting isAddingTask state True
) {
    var selectedItem by remember { mutableIntStateOf(0) }
    val items = listOf("Home", "Tasks")
    val icons = listOf(Icons.Filled.Home, Icons.AutoMirrored.Filled.List, Icons.Filled.Settings)

    NavigationBar (
        Modifier.height(65.dp)
    ) {
        items.forEachIndexed { index, item ->

            NavigationBarItem(
                label = { Text(item) },
                selected = selectedItem == index,
                onClick = { selectedItem = index },
                icon = { Icon(icons[index], contentDescription = item) },
            )

        }

        // Add New Task Button
        NavigationBarItem(
            label = { Text("Add") },
            selected = true,
            onClick = onAddNewClick, // For setting isAddingTask state True
            icon = {
                Icon (
                    imageVector = Icons.Default.Add,
                    contentDescription = "Add"
                )
            },
        )
    }
}

// Content from MainDrawer.kt
package com.app.routineturboa.ui.scaffold


@RequiresApi(Build.VERSION_CODES.S)
@Composable
fun MainDrawer(
    drawerState: DrawerState,
    tasksViewModel: TasksViewModel,
    reminderManager: ReminderManager
) {
    val context = LocalContext.current
    val appName = context.getString(R.string.app_name)
    val coroutineScope = rememberCoroutineScope()

    val configuration = LocalConfiguration.current
    val screenWidth = configuration.screenWidthDp.dp
    val screenHeight = configuration.screenHeightDp.dp

    ModalDrawerSheet(
        //region ModalDrawerSheet Parameters
        drawerContainerColor = MaterialTheme.colorScheme.surface,
        drawerContentColor = MaterialTheme.colorScheme.onSurface,
        drawerTonalElevation = 9.dp,

        modifier = Modifier
            .width(screenWidth * 0.7f)
            .height(screenHeight * 0.90f)
            .padding(top = 12.dp)
            .offset(x = if (drawerState.isClosed) -screenWidth else 0.dp)
            .shadow(15.dp),
        drawerShape = RectangleShape
        //endregion
    ) {
        // Content inside drawer
        Column(
            modifier = Modifier
                .fillMaxSize()
                .verticalScroll(rememberScrollState())
        ) {
            // Top Header
            Surface(
                color = MaterialTheme.colorScheme.primary,
                modifier = Modifier.shadow(15.dp)
            ) {
                // Top Item with App Name
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.SpaceBetween,
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 12.dp, horizontal = 10.dp)
                ) {
                    // region App Main Icon
                    Image(
                        painter = painterResource(id = R.drawable.routineturbo),
                        contentDescription = "App Icon",
                        modifier = Modifier
                            .size(40.dp)
                            .clip(CircleShape)
                    )
                    // endregion

                    Spacer(modifier = Modifier.width(10.dp))

                    Text(
                        text = appName,
                        style = MaterialTheme.typography.titleMedium,
                        color = MaterialTheme.colorScheme.onPrimary
                    )

                    Spacer(modifier = Modifier.weight(1f))

                    Icon(
                        Icons.AutoMirrored.Outlined.MenuOpen,
                        contentDescription = null, // Handle accessibility if needed
                        modifier = Modifier
                            .size(24.dp) // Adjust size as necessary
                            .clickable {
                                coroutineScope.launch { drawerState.close() }
                            },
                        tint = Color.Gray
                    )
                }
            }

            // OneDrive Sign in, Sync, and LogOut buttons
            SignInAndSyncButtons(tasksViewModel)

            // Schedule reminders
            DrawerItemTemplate("Schedule Reminders", Icons.Default.Build) {
                coroutineScope.launch {
                    reminderManager.observeAndScheduleReminders(context)
                }
            }

            // Insert default tasks
            DrawerItemTemplate("Insert Default Tasks", Icons.Default.Settings) {
                coroutineScope.launch {
                    tasksViewModel.insertDefaultTasks()
                }
            }

            // Insert demo tasks
            DrawerItemTemplate("Insert Demo Tasks", Icons.Default.Settings) {
                coroutineScope.launch {
                    tasksViewModel.insertDemoTasks(context)
                }
            }

            // Delete all tasks
            DrawerItemTemplate("Delete All", Icons.Default.Settings) {
                coroutineScope.launch {
                    tasksViewModel.deleteAllTasks()
                }
            }
        }
    }
}

@Composable
fun DrawerItemTemplate(
    text: String,
    icon: ImageVector,
    loading:Boolean=false,
    onItemClick: () -> Unit
) {
    Row(
        verticalAlignment = Alignment.CenterVertically,
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onItemClick)
            .padding(16.dp)
    ) {
        Icon(
            imageVector = icon,
            contentDescription = null, // Handle accessibility if needed
            modifier = Modifier.size(24.dp) // Adjust size as necessary
        )
        Spacer(modifier = Modifier.width(16.dp)) // Adjust spacing between icon and text
        Text(
            text = text,
            style = MaterialTheme.typography.bodyLarge
        )
        if (loading) {
            SmoothCircularProgressIndicator()
        }
    }
}



// Content from MainTopBar.kt
package com.app.routineturboa.ui.scaffold


@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MainTopBar(drawerState: DrawerState) {
    val currentDate: String = SimpleDateFormat("MMMM d",
        Locale.getDefault()).format(Date())
    val coroutineScope = rememberCoroutineScope()

    val scrollBehavior = exitUntilCollapsedScrollBehavior()

    TopAppBar(
        //<editor-fold desc="TopAppBar Parameters">
        colors = TopAppBarDefaults.largeTopAppBarColors(
            containerColor = MaterialTheme.colorScheme.primary,
            titleContentColor = MaterialTheme.colorScheme.onPrimary,
        ),
        title = { Text(text = currentDate) },
        navigationIcon = {
            IconButton(
                onClick = { coroutineScope.launch { drawerState.open() } }
            ) {
                Icon(
                    Icons.Outlined.Menu,
                    contentDescription = "Menu"
                )
            }
        },
        actions = {
            IconButton(
                onClick = { /*TODO: Main Top Bar button action.*/ }
            ) {
                Icon(
                    Icons.Outlined.ViewDay,
                    contentDescription = "View Day"
                )
            }
        },
        scrollBehavior = scrollBehavior,
        //</editor-fold>
    )
}


// Content from QuickEdit.kt
package com.app.routineturboa.ui.task.child


@RequiresApi(Build.VERSION_CODES.S)
@Composable
fun QuickEdit(
    mainTasks: List<TaskEntity>?,
    task: TaskEntity,
    isFullEditing: Boolean,
    onFullEditClick: (Int) -> Unit,
    onConfirmEdit: () -> Unit,
    onCancel: () -> Unit,
) {
    val tag = "QuickEditScreen"
    val context = LocalContext.current


    val startTime by remember { mutableStateOf(task.startTime) }
    var taskName by remember { mutableStateOf(task.name) }
    var durationString by remember { mutableStateOf(task.duration.toString()) }
    var endTime by remember { mutableStateOf(task.endTime) }
    var endTimeString by remember { mutableStateOf(dateTimeToString(endTime)) }

    LaunchedEffect(durationString) {
        if (durationString.isNotEmpty()) {
            try {
                endTimeString =
                    dateTimeToString(task.startTime.plusMinutes(durationString.toLong()))
            } catch (e: NumberFormatException) {
                Toast.makeText(context, "Invalid duration format", Toast.LENGTH_SHORT).show()
            }
        }
    }

    Column(modifier = Modifier.padding(5.dp)) {
        // Task Name and Duration Row
        Row(
            modifier = Modifier
                .fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(15.dp)
        ) {
            Box (
                modifier = Modifier
                    .weight(2f)
                    .height(45.dp)
                    .background(
                        MaterialTheme.colorScheme.surfaceContainerHigh.copy(alpha = 0.6f),
                        MaterialTheme.shapes.small
                    ),
            ) {
                BasicTextField(
                    value = taskName,
                    onValueChange = { newTaskName -> taskName = newTaskName },
                    singleLine = true,
                    textStyle = MaterialTheme.typography.titleMedium.copy(
                        color = MaterialTheme.colorScheme.onSurface
                    ),
                    decorationBox = { innerTextField ->
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            modifier = Modifier
                                .padding(start=10.dp)
                                .fillMaxHeight() // This makes sure the content is centered vertically
                        ) {
                            if (taskName.isEmpty()) {
                                Text(
                                    "task name..."
                                )
                            }
                            innerTextField()
                        }

                    }
                )
            }

            Box(
                modifier = Modifier
                    .weight(1f)
                    .height(45.dp)
                    .background(
                        MaterialTheme.colorScheme.surfaceContainerHigh.copy(alpha = 0.6f),
                        MaterialTheme.shapes.small
                    ),

                ) {
                BasicTextField(
                    value = durationString,
                    onValueChange = { newDuration -> durationString = newDuration },
                    singleLine = true,
                    textStyle = MaterialTheme.typography.titleMedium.copy(
                        color = MaterialTheme.colorScheme.onSurface
                    ),
                    decorationBox = { innerTextField ->
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            modifier = Modifier
                                .padding(start=10.dp)
                                .fillMaxHeight() // This makes sure the content is centered vertically
                        ) {
                            if (durationString.isEmpty()) {
                                Text("Duration...")
                            }
                            innerTextField()
                        }
                    }
                )
            }
        }

        Spacer(modifier = Modifier.height(10.dp))

        // Save and Cancel Buttons Row
        Row(
            modifier = Modifier.fillMaxWidth()
                .height(43.dp), // Set the height for the entire row

            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            // Full-Screen Edit Button
            Button(
                onClick = { onFullEditClick(task.id) },
                modifier = Modifier.fillMaxHeight(),
                shape = RoundedCornerShape(15.dp),
                contentPadding = PaddingValues(10.dp),
                colors = ButtonDefaults.buttonColors(
                    containerColor = MaterialTheme.colorScheme.inversePrimary.copy(alpha =0.2f),
                    contentColor = MaterialTheme.colorScheme.onPrimary
                )
            ) {
                Text("Full-screen Editing",
                    style = MaterialTheme.typography.labelLarge)
            }

            // Save Button
            Button(
                onClick = {
                    try {
                        endTimeString = dateTimeToString(startTime.plusMinutes(durationString.toLong()))
                        endTime = strToDateTime(endTimeString)

                        val taskWithUpdatedData =
                            task.copy(name = taskName, duration = durationString.toInt(), endTime = endTime)

                        onConfirmEdit()

                    } catch (e: Exception) {
                        Log.e(tag, "Error: $e")
                        Toast.makeText(
                            context,
                            "Error saving task values: ${e.message}",
                            Toast.LENGTH_LONG
                        ).show()
                    }

                },
                modifier = Modifier.fillMaxHeight(),
                shape = RoundedCornerShape(15.dp),
                contentPadding = PaddingValues(10.dp),
                colors = ButtonDefaults.buttonColors(
                    containerColor = MaterialTheme.colorScheme.inversePrimary.copy(alpha = 0.2f),
                    contentColor = MaterialTheme.colorScheme.onPrimary
                )
            ) {
                Text("Save",
                    style = MaterialTheme.typography.labelLarge)
            }
        }

        if (isFullEditing) {
            FullEditDialog(
                mainTasks = mainTasks?: emptyList(),
                task = task,
                onConfirmEdit = onConfirmEdit,
                onCancel = onCancel
            )
        }
    }
}



// Content from AddTaskDialog.kt
package com.app.routineturboa.ui.task.dialogs



@Composable
fun AddTaskDialog(
    mainTasks: List<TaskEntity>,
    clickedTask: TaskEntity? = null,
    taskBelowClickedTask: TaskEntity? = null,
    onAddClick: (TaskFormData) -> Unit,
    onCancel: () -> Unit
) {
    val tag = "AddTaskDialog"

    if (clickedTask == null) {
        Log.e(tag, "clickedTask is null")
        Toast.makeText(LocalContext.current, "Click a task first.", Toast.LENGTH_SHORT).show()
        return
    }

    Log.d(tag, "clickedTask: $clickedTask")

    // Context and Initial Task Data
    val context = LocalContext.current
    val clickedTaskEndTime = clickedTask.endTime
    val clickedTaskID = clickedTask.id
    val clickedTaskPosition = clickedTask.position

    // Data in State variables
    val id by remember { mutableIntStateOf(clickedTaskID + 1) }
    var startTime by remember { mutableStateOf(clickedTaskEndTime) }
    val defaultDuration = 1L
    var endTime by remember { mutableStateOf(startTime.plusMinutes(defaultDuration)) }
    var taskName by remember { mutableStateOf(" ") }
    var notes by remember { mutableStateOf( " ") }
    var duration by remember { mutableLongStateOf(defaultDuration) }
    var reminder by remember { mutableStateOf(startTime) }
    var taskType by remember { mutableStateOf("") }

    // Add 1 to position of new task
    var taskPosition by remember { mutableIntStateOf(clickedTaskPosition.plus(1)) }

    // Convert state variables to  string for display
    var startTimeFormatted by remember {mutableStateOf(dateTimeToString(startTime))}
    var endTimeFormatted by remember {mutableStateOf(dateTimeToString(endTime))}
    var reminderFormatted by remember {mutableStateOf(dateTimeToString(reminder))}
    var durationFormatted by remember {mutableStateOf(duration.toString())}
    val idFormatted by remember {mutableStateOf(id.toString())}
    var positionFormatted by remember {mutableStateOf(taskPosition.toString())}


    val durationTaskBelowBeforeAdding = taskBelowClickedTask?.duration

    var isReminderLinked by remember { mutableStateOf(true) }

    Log.d(tag, "clicked task name and position: ${clickedTask.name} ${clickedTask.position}")
    Log.d(tag, "clicked task end time: ${clickedTask.endTime}")
    Log.d(tag, "new task start time: $startTimeFormatted")

    // State to hold selected main task ID
    var linkedMainTaskIdIfHelper by remember { mutableStateOf<Int?>(null) }

    // Calculate endTime based on duration input
    LaunchedEffect(durationFormatted) {
        if (durationFormatted.isNotEmpty()) {
            try {
                val durationLong = durationFormatted.toLong()
                if (durationLong > 0 || durationLong < durationTaskBelowBeforeAdding!!) {
                    endTimeFormatted = dateTimeToString(startTime.plusMinutes(durationLong))
                } else {
                    Toast.makeText(context, "Invalid duration. End time unchanged.", Toast.LENGTH_SHORT).show()
                }
            } catch (e: NumberFormatException) {
                Toast.makeText(context, "Invalid duration format. End time unchanged.", Toast.LENGTH_SHORT).show()
            }
        } else {
            Toast.makeText(context, "Duration is empty. End time unchanged.", Toast.LENGTH_SHORT).show()
        }
    }

    // Calculate Duration based on End Time
    LaunchedEffect(endTimeFormatted) {
        if (endTimeFormatted.isNotEmpty()) {
            try {
                // Attempt to parse the end time string
                val endTimeParsed = strToDateTime(endTimeFormatted)

                if (endTimeParsed.isAfter(startTime)) {
                    // Calculate the duration in minutes
                    val durationInMinutes = java.time.Duration.between(startTime, endTimeParsed).toMinutes()

                    // Update the durationFormatted state variable
                    durationFormatted = durationInMinutes.toString()
                } else {
                    // End time is not valid or is not after start time
                    Toast.makeText(context, ".", Toast.LENGTH_SHORT).show()
                }
            } catch (e: Exception) {
                // Handle any unexpected exceptions
                Toast.makeText(context, "Error processing end time.", Toast.LENGTH_SHORT).show()
            }
        }
    }

    // Update reminder time if linked
    LaunchedEffect(startTimeFormatted) {
        if (isReminderLinked) {
            reminderFormatted = startTimeFormatted
        }
    }

    // Listen for changes in the task type dropdown
    LaunchedEffect(taskType) {
        if (taskType == "HelperTask") {
            // Reset selectedMainTaskId when task type is changed to HelperTask
            linkedMainTaskIdIfHelper = null
        }
    }

    Dialog(
        onDismissRequest = { onCancel() },
        properties = DialogProperties(usePlatformDefaultWidth = false),
    ) {
        Surface(
            modifier = Modifier
                .fillMaxWidth(0.9f),
            color = MaterialTheme.colorScheme.secondaryContainer,
            contentColor = MaterialTheme.colorScheme.onSecondaryContainer
        ) {
            Column(
                modifier = Modifier
                    .padding(8.dp)
                    .fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(10.dp)
            ) {
                Text("Add New Task", style = MaterialTheme.typography.titleLarge)

                CustomTextField(
                    value = taskName,
                    onValueChange = { taskName = it },
                    label = "Task Name",
                    placeholder = "Enter task name",
                    leadingIcon = Icons.Default.AddTask,
                    modifier = Modifier.fillMaxWidth()
                )

                // Start Time and Reminder Side by Side with Link/Link-off button
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    CustomTextField(
                        value = startTimeFormatted,
                        onValueChange = { startTimeFormatted = it },
                        label = "Start Time",
                        placeholder = "Enter start time",
                        leadingIcon = Icons.Sharp.Start,
                        modifier = Modifier.weight(1f),
                    )

                    Icon (
                        imageVector = if (isReminderLinked) Icons.Default.Link else Icons.Default.LinkOff,
                        contentDescription = "Link Reminder",
                        modifier = Modifier
                            .clickable {
                                isReminderLinked = !isReminderLinked
                                if (isReminderLinked) {
                                    reminderFormatted = startTimeFormatted
                                }
                            }
                            .align(Alignment.CenterVertically)
                            .size(30.dp)
                    )

                    CustomTextField(
                        value = reminderFormatted,
                        onValueChange = { reminderFormatted = it },
                        label = "Reminder",
                        placeholder = "Enter reminder time",
                        leadingIcon = Icons.Sharp.AddAlert,
                        enabled = !isReminderLinked,
                        modifier = Modifier.weight(1f)
                    )
                }

                // Duration and End Time Side by Side
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    CustomTextField(
                        value = durationFormatted,
                        onValueChange = { durationFormatted = it },
                        label = "Duration",
                        placeholder = "Enter duration",
                        leadingIcon = Icons.Sharp.Timer,
                        keyboardOptions = KeyboardOptions.Default.copy(keyboardType = KeyboardType.Number),
                        modifier = Modifier.weight(1f),
                    )

                    CustomTextField(
                        value = endTimeFormatted,
                        onValueChange = { endTimeFormatted = it },
                        label = "End Time",
                        placeholder = "Enter End Time",
                        leadingIconResId = R.drawable.arrowrighttoleft,
                        modifier = Modifier.weight(1f),
                    )
                }

                CustomTextField(
                    value = notes,
                    onValueChange = { notes = it },
                    label = "Notes",
                    placeholder = "Add Notes",
                    leadingIcon = Icons.Default.Link,
                    modifier = Modifier
                        .fillMaxWidth(),
                    singleLine = false
                )

                // Task type dropdown
                SelectTaskTypeDropdown(
                    selectedTaskType = taskType,
                    onTaskTypeSelected = { newType ->
                        taskType = newType
                    }
                )

                // Show the main task dropdown only if task type is "HelperTask"
                if (taskType == TaskTypes.HELPER) {
                    ShowMainTasksDropdown(
                        mainTasks = mainTasks,
                        selectedMainTaskId = linkedMainTaskIdIfHelper,
                        onTaskSelected = { taskId -> linkedMainTaskIdIfHelper = taskId }
                    )
                }

                TextField(
                    value = idFormatted,
                    onValueChange = { },
                    label = { Text("Task ID") },
                    enabled = false,
                    modifier = Modifier.fillMaxWidth(),
                )

                CustomTextField(
                    value = positionFormatted,
                    onValueChange = {positionFormatted = it},
                    label = "Position (Don't Change) (Only for dev)",
                    placeholder = "Internal purposes. Don't change.",
                    modifier = Modifier.fillMaxWidth(),
                    enabled = true
                )

                Row(
                    horizontalArrangement = Arrangement.SpaceBetween,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    // Cancel Button
                    Button(
                        modifier = Modifier.padding(5.dp),
                        shape = RoundedCornerShape(25.dp),
                        onClick = onCancel
                    ) { Text("Cancel") }

                    // Add Button
                    Button(
                        modifier = Modifier.padding(5.dp),
                        shape = RoundedCornerShape(25.dp),
                        onClick = {
                            if (taskName.isNotBlank() && duration > 0) {
                                startTime = strToDateTime(startTimeFormatted)
                                endTime = strToDateTime(endTimeFormatted)
                                reminder = strToDateTime(reminderFormatted)
                                duration = durationFormatted.toLong()
                                taskPosition = positionFormatted.toInt()

                                val newTaskFormData = TaskFormData(
                                    position = taskPosition,
                                    name = taskName,
                                    notes = notes,
                                    startTime = startTime,
                                    endTime = endTime,
                                    duration = duration.toInt(),
                                    reminder = reminder,
                                    mainTaskId = linkedMainTaskIdIfHelper, // Link to the selected main task,
                                    taskType = taskType
                                )

                                onAddClick(newTaskFormData)

                            } else {
                                Toast.makeText(context,
                                    "Please fill all fields correctly", Toast.LENGTH_SHORT).show()
                            }
                        }
                    ) { Text("Add")}  // END Add Button
                }  // Buttons Row
            }
        }
    }
}

// Content from FullEditDialog.kt
package com.app.routineturboa.ui.task.dialogs


@RequiresApi(Build.VERSION_CODES.S)
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun FullEditDialog(
    mainTasks: List<TaskEntity>,
    task: TaskEntity,
    onConfirmEdit: () -> Unit,
    onCancel: () -> Unit
) {
    val context = LocalContext.current
    var linkedMainTaskIdIfHelper by remember { mutableStateOf<Int?>(null) }

    // Actual data in State variables from 'task'
    var id by remember { mutableIntStateOf(task.id) }
    var taskName by remember { mutableStateOf(task.name) }
    var notes by remember { mutableStateOf(task.notes) }
    var startTime by remember { mutableStateOf(task.startTime) }
    var endTime by remember { mutableStateOf(task.endTime) }
    var duration by remember { mutableIntStateOf(task.duration) }
    var reminder by remember { mutableStateOf(task.reminder) }
    var position by remember { mutableIntStateOf(task.position) }
    var taskType by remember { mutableStateOf(task.type) }

    // Convert state variables to  string for display
    var startTimeString by remember {mutableStateOf(dateTimeToString(startTime))}
    var endTimeString by remember {mutableStateOf(dateTimeToString(endTime))}
    var reminderString by remember {mutableStateOf(dateTimeToString(reminder))}
    var durationString by remember {mutableStateOf(duration.toString())}
    val idFormatted by remember {mutableStateOf(id.toString())}
    var positionString by remember {mutableStateOf(position.toString())}

    val coroutineScope = rememberCoroutineScope()
    var isReminderLinked by remember { mutableStateOf(true) }

    Dialog(
        onDismissRequest = {onCancel()},
        properties = DialogProperties(usePlatformDefaultWidth = false),
    ) {
        Surface(
            modifier = Modifier
                .fillMaxWidth(0.9f),
            color = MaterialTheme.colorScheme.secondaryContainer,
            contentColor = MaterialTheme.colorScheme.onSecondaryContainer
        ) {
            Column(
                modifier = Modifier
                    .padding(8.dp)
                    .fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(10.dp)
            ) {
                Text("Edit Task", style = MaterialTheme.typography.titleLarge)

                CustomTextField(
                    value = taskName,
                    onValueChange = { taskName = it },
                    label = "Task Name",
                    placeholder = "Enter task name",
                    leadingIcon = Icons.Default.AddTask,
                    modifier = Modifier.fillMaxWidth()
                )

                // Start Time and Reminder Side by Side with Link/Link-off button
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(2.dp),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    CustomTextField(
                        value = startTimeString,
                        onValueChange = { startTimeString = it },
                        label = "Start Time",
                        placeholder = "Enter start time",
                        leadingIcon = Icons.Sharp.Start,
                        modifier = Modifier.weight(1f),
                    )

                    Icon (
                        imageVector = if (isReminderLinked) Icons.Default.Link
                        else Icons.Default.LinkOff,
                        contentDescription = "Link Reminder",
                        modifier = Modifier
                            .clickable {
                                isReminderLinked = !isReminderLinked
                                if (isReminderLinked) {
                                    reminderString = startTimeString
                                }
                            }
                            .align(Alignment.CenterVertically)
                            .size(25.dp)
                    )

                    CustomTextField(
                        value = reminderString,
                        onValueChange = { reminderString = it },
                        label = "Reminder",
                        placeholder = "Enter reminder time",
                        leadingIcon = Icons.Sharp.AddAlert,
                        enabled = !isReminderLinked,
                        modifier = Modifier.weight(1f)
                    )
                }

                // Duration and End Time Side by Side
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    LaunchedEffect (durationString){
                        if (durationString.isNotEmpty()) {
                            try {
                                endTimeString = dateTimeToString(startTime.plusMinutes(durationString.toLong()))
                            } catch (e: NumberFormatException) {
                                Toast.makeText(context, "Invalid duration format", Toast.LENGTH_SHORT).show()
                            }
                        }

                    }

                    CustomTextField(
                        value = durationString,
                        onValueChange = { durationString = it },
                        label = "Duration",
                        placeholder = "Enter duration",
                        leadingIcon = Icons.Sharp.Timer,
                        keyboardOptions = KeyboardOptions.Default.copy(keyboardType = KeyboardType.Number),
                        modifier = Modifier.weight(1f),
                    )

                    CustomTextField(
                        value = endTimeString,
                        onValueChange = { endTimeString = it },
                        label = "End Time",
                        placeholder = "Enter End Time",
                        leadingIconResId = R.drawable.arrowrighttoleft,
                        modifier = Modifier.weight(1f),
                    )
                }

                CustomTextField(
                    value = notes,
                    onValueChange = { notes = it },
                    label = "Notes",
                    placeholder = "Add Notes",
                    leadingIcon = Icons.Default.Link,
                    modifier = Modifier
                        .fillMaxWidth(),
                    singleLine = false
                )

                SelectTaskTypeDropdown(
                    taskType,
                    onTaskTypeSelected = { newType -> taskType = newType }
                )

                // Show the main task dropdown only if task type is "HelperTask"
                if (taskType == "HelperTask") {
                    ShowMainTasksDropdown(
                        mainTasks = mainTasks,
                        selectedMainTaskId = linkedMainTaskIdIfHelper,
                        onTaskSelected = { taskId -> linkedMainTaskIdIfHelper = taskId }
                    )
                }

                CustomTextField(
                    value = idFormatted,
                    onValueChange = { },
                    label = "ID (Only for dev)",
                    placeholder = "Internal purposes",
                    enabled = false,
                    modifier = Modifier.fillMaxWidth(),
                )

                CustomTextField(
                    value = positionString,
                    onValueChange = {positionString = it},
                    label = "Position (Don't Change) (Only for dev)",
                    placeholder = "Internal purposes. Don't change.",
                    modifier = Modifier.fillMaxWidth(),
                    enabled = true
                )

                Row(
                    horizontalArrangement = Arrangement.SpaceBetween,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    // Cancel Button
                    Button(
                        modifier = Modifier
                            .padding(5.dp)
                            .size(120.dp, 50.dp),
                        shape = RoundedCornerShape(25.dp),

                        onClick = { onCancel() },
                        colors = ButtonDefaults.buttonColors(
                            LocalCustomColorsPalette.current.gray200,
                        )

                    ) {
                        Text("Cancel")
                    }

                    // Save Button
                    FloatingActionButton(
                        containerColor = MaterialTheme.colorScheme.primary,
                        modifier = Modifier
                            .padding(5.dp)
                            .size(120.dp, 50.dp),
                        elevation = FloatingActionButtonDefaults.elevation(10.dp),
                        onClick = {
                            Log.d("EditTaskScreen", "Save Button clicked...")
                            coroutineScope.launch {
                                try {
                                    startTime = strToDateTime(startTimeString)
                                    endTime = strToDateTime(endTimeString)
                                    reminder = strToDateTime(reminderString)
                                    duration = durationString.toInt()
                                    id = idFormatted.toInt()
                                    position = positionString.toInt()

                                } catch (e: Exception) {
                                    Log.e("EditTaskScreen", "Error: $e")
                                    Toast.makeText(context, "Error saving task: ${e.message}", Toast.LENGTH_LONG).show()
                                }

                                val updatedTask = task.copy(
                                    name = taskName,
                                    position = position,
                                    notes = notes,
                                    startTime = startTime,
                                    endTime = endTime,
                                    reminder = reminder,
                                    duration = duration,
                                    type = taskType
                                )

                                onConfirmEdit()

                            } // End of Coroutine
                        }
                    ) {
                        Text("Save")
                    }
                }


            }
        }
    }
}


// Content from TaskDetailsDialog.kt
package com.app.routineturboa.ui.task.dialogs


@Composable
fun TaskDetailsDialog(
    task: TaskEntity,
    onDismiss: () -> Unit
) {
    AlertDialog(
        onDismissRequest = { onDismiss() },
        properties = DialogProperties(usePlatformDefaultWidth = true),
        confirmButton = {
            TextButton(
                onClick = { onDismiss() },
            ) {
                Text("Close", style = MaterialTheme.typography.titleMedium.copy(
                    color = MaterialTheme.colorScheme.onPrimary))
            }
        },
        icon = {
            Icon(
                imageVector = Icons.Default.Info,
                contentDescription = "Task Info",
                tint = MaterialTheme.colorScheme.onPrimary
            )
        },
        title = {
            Text(
                text = "${task.name} [${task.duration} Mins]",
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Bold,
            )
        },
        text = {
            Surface(
                modifier = Modifier
                    .fillMaxWidth(0.9f)
            ) {
                Column(
                    verticalArrangement = Arrangement.spacedBy(15.dp),
                    modifier = Modifier.padding(top = 10.dp)
                ) {
                    // Time information
                    Row(
                        horizontalArrangement = Arrangement.SpaceBetween,
                    ) {
                        Column {
                            Text(
                                text = "Start",
                                style = MaterialTheme.typography.titleMedium,
                                color = MaterialTheme.colorScheme.onPrimary
                            )
                            Text(
                                text = dateTimeToString( task.startTime),
                                style = MaterialTheme.typography.titleSmall
                            )
                        }

                        Spacer(modifier = Modifier.width(25.dp))
                        Column {
                            Text(
                                text = "End",
                                style = MaterialTheme.typography.titleMedium,
                                color = MaterialTheme.colorScheme.onPrimary
                            )
                            Text(
                                text = dateTimeToString( task.endTime),
                                style = MaterialTheme.typography.titleSmall
                            )
                        }

                    }

                    Column {
                        Text(
                            text = "Notes",
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.onPrimary
                        )
                        Text(
                            text = task.notes.takeIf { it.isNotBlank() } ?: "None",
                            style = MaterialTheme.typography.titleSmall
                        )
                    }

                    // Reminder
                    Column {
                        Text(
                            text = "Reminder",
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.onPrimary
                        )
                        Text(
                            text = dateTimeToString(task.reminder),
                            style = MaterialTheme.typography.titleSmall
                        )
                    }

                    // Type
                    Column {
                        Text(
                            text = "Type",
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.onPrimary
                        )
                        Text(
                            text = task.type,
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }

                    // Internal details
                    Column {
                        Text(
                            text = "Internal Details",
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.onPrimary
                        )
                        Text(
                            text = "ID: ${task.id}",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        Text(
                            text = "Position: ${task.position}",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
            }
        },
        modifier = Modifier.padding(0.dp)
    )
}

// Content from TasksViewModel.kt
package com.app.routineturboa.viewmodel


class TasksViewModel(private val repository: DataRepository) : ViewModel() {
    private val tag = "TasksViewModel"

    val tasks: StateFlow<List<TaskEntity>> = repository.tasks
        // Expose tasks regular flow from Repository as a StateFlow to be collected by UI
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )

    // Define private internal Mutable state flow with TaskUiState data class
    private val _tasksUiState = MutableStateFlow(TasksUiState())
    // Expose UI state as a StateFlow to be collected by UI
    val tasksUiState: StateFlow<TasksUiState> = _tasksUiState.asStateFlow()

    // Functions to update UI state
    fun onAnyTaskClick(taskId: Int) {
        Log.d(tag, "onAnyTaskClick: $taskId")
        _tasksUiState.update {
            it.copy(
                clickedTaskId = taskId,
                inEditTaskId = null,
                isQuickEditing = false,
                isFullEditing = false,
            )
        }
    }

    fun onAnyTaskLongPress(taskId: Int) {
        onAnyTaskClick(taskId)
        _tasksUiState.update {
            it.copy(
                longPressedTaskId = taskId,
            )
        }
    }

    fun onAddNewClick(){
        if (_tasksUiState.value.clickedTaskId != null) {
            _tasksUiState.update {
                it.copy(
                    isAddingNew = true,
                    taskBelowClickedTaskId = it.clickedTaskId?.plus(1)
                )
            }
        }

    }

    fun onQuickEditClick(taskId: Int) {
        Log.d(tag, "onQuickEditClick: $taskId")
        _tasksUiState.update {
            it.copy(
                clickedTaskId = taskId,
                inEditTaskId = taskId,
                isQuickEditing = true,
                isFullEditing = false,
            )
        }
    }

    fun onFullEditTask(taskId: Int) {
        Log.d(tag, "onFullEditTask: $taskId")
        _tasksUiState.update {
            it.copy(
                clickedTaskId = null,
                inEditTaskId = taskId,
                isQuickEditing = false,
                isFullEditing = true,
            )
        }
    }

    fun onShowTaskDetails(taskId: Int) {
        Log.d(tag, "onShowTaskDetails: $taskId")
        _tasksUiState.update {
            it.copy(
                isShowingDetails = true,
                showingDetailsTaskId = taskId,
                isQuickEditing = false,
                isFullEditing = false,
            )
        }
    }

    fun onNewTaskSaveClick(newTaskFormData: TaskFormData) {

        _tasksUiState.update {
            it.copy(
                isAddingNew = true,
                taskBelowClickedTaskId = it.clickedTaskId?.plus(1)
            )
        }

        beginNewTaskOperations(newTaskFormData)
    }

    fun onCancelEdit() {
        Log.d(tag, "onCancelEdit")
        _tasksUiState.update {
            it.copy(
                isAddingNew = false,
                inEditTaskId = null,
                isQuickEditing = false,
                isFullEditing = false,
                isShowingDetails = false,
            )
        }
    }

    fun onConfirmEdit() {
        Log.d(tag, "onConfirmEdit")
        _tasksUiState.update {
            it.copy(
                isAddingNew = false,
                isQuickEditing = false,
                isFullEditing = false,
            )
        }
    }

    fun onDeleteTask(taskId: Int? = _tasksUiState.value.clickedTaskId) {
        if (taskId == null) return
        val task = tasks.value.find { it.id == taskId } ?: return
        Log.d(tag, "Deleting task: ${task.name}")
        viewModelScope.launch {
            repository.deleteTask(task)
        }

        // update the UI state
        _tasksUiState.update {
            it.copy(
                inEditTaskId = null,
                isQuickEditing = false,
                isFullEditing = false,
            )
        }
    }

    // Get next task after a reference task
    fun getNextTask(referenceTask: TaskEntity): TaskEntity? {
        val currentTasks = tasks.value
        val index = currentTasks.indexOfFirst { it.id == referenceTask.id }
        return if (index != -1 && index < currentTasks.size - 1) {
            currentTasks[index + 1]
        } else {
            null
        }
    }

    // Sync tasks from OneDrive
    fun syncTasksFromOneDrive(context: Context) {
        viewModelScope.launch {
            try {
                val authManager = MsalAuthManager.getInstance(context)
                val authResult = authManager.signIn(context as Activity)
                authResult.let {
                    repository.syncTasksFromOneDrive(it, context)
                }
            } catch (e: Exception) {
                Log.e(tag, "Error syncing tasks from OneDrive", e)
            }
        }
    }

    fun getTasksByType(type: String): Flow<List<TaskEntity>> {
        return repository.getTasksByType(type)
    }

    // Update task and adjust next
    fun updateTaskAndAdjustNext(initialEditedTask: TaskEntity) {
        viewModelScope.launch {
            repository.updateTaskAndAdjustNext(initialEditedTask)
        }
    }

    // Begin new task operations
    private fun beginNewTaskOperations(newTaskFormData: TaskFormData): LiveData<Result<Boolean>> {
        val resultLiveData = MutableLiveData<Result<Boolean>>()
        val clickedTaskEntity = tasks.value.find { it.id == _tasksUiState.value.clickedTaskId }
        val newTaskEntity = createTaskEntityFromForm(newTaskFormData)

        if (clickedTaskEntity != null) {
            viewModelScope.launch {
                val result = repository.beginNewTaskOperations(clickedTaskEntity, newTaskEntity)
                resultLiveData.postValue(result)
            }
        }
        return resultLiveData
    }

    private fun createTaskEntityFromForm(form: TaskFormData): TaskEntity {
        return TaskEntity(
            position = form.position,
            name = form.name,
            notes = form.notes,
            startTime = form.startTime,
            endTime = form.endTime,
            duration = form.duration,
            reminder = form.reminder,
            type = form.taskType,
            mainTaskId = form.mainTaskId
        )
    }


    fun deleteAllTasks() {
        Log.d(tag, "Deleting all tasks...")
        viewModelScope.launch {
            repository.deleteAllTasks()
        }
    }

    fun insertDemoTasks(context: Context) {
        Log.d(tag, "Inserting demo tasks.")
        viewModelScope.launch {
            Log.d(tag, "First, deleting the tasks...")
            deleteAllTasks()
            try {
                val demoTasks = getDemoTasks(context)
                demoTasks.forEach { task ->
                    repository.insertTask(task)
                }
            } catch (e: Exception) {
                Log.e("TasksViewModel", "Error inserting demo tasks", e)
            } finally {
            }
        }
    }

    fun insertDefaultTasks() {
        Log.d(tag, "Initializing Default tasks.")
        viewModelScope.launch {
            try {
                repository.initializeDefaultTasks()
            } finally {
            }
        }
    }

    //<editor-fold desc="Logic for creating currentTask StateFlow">

    // Current time flow emitting LocalDateTime every set seconds (set to 10 minutes)
    private val currentTimeFlow: Flow<LocalDateTime> = dateTimeEmitterFlow(600)

    // Define the StateFlow for the current task
    private val currentTask: StateFlow<TaskEntity?> = getCurrentTaskFlow(tasks, currentTimeFlow)

    private fun getCurrentTaskFlow(
        tasksFlow: StateFlow<List<TaskEntity>>,
        currentTimeFlow: Flow<LocalDateTime>,
    ): StateFlow<TaskEntity?> {
        // Combine tasks and current time to find the active task
        val currentTaskFlow = combine(tasksFlow, currentTimeFlow) { taskList, currentTime ->
            taskList.find { it.startTime <= currentTime && currentTime < it.endTime }
        }

        // Convert combined flow into StateFlow
        return currentTaskFlow.stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = null
        )
    }


    //</editor-fold>
}

