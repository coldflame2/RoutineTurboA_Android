
// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\AndroidManifest.xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        tools:targetApi="31">
        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <!-- MSAL BrowserTabActivity configuration -->
        <activity
            android:name="com.microsoft.identity.client.BrowserTabActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />
                <data android:scheme="msauth"
                    android:host="com.app.routineturboa"
                    android:path="/a0VHP+Yc7DrhJPus83+LbjsqzHY=" />
            </intent-filter>
        </activity>

    </application>
</manifest>

// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\build.gradle.kts
plugins {
    alias(libs.plugins.androidApplication)
    alias(libs.plugins.jetbrainsKotlinAndroid)
}

android {
    namespace = "com.app.routineturboa"
    compileSdk = 34

    defaultConfig {
        applicationId = "com.app.routineturboa"
        minSdk = 30
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
        versionNameSuffix = "1"
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
    kotlinOptions {
        jvmTarget = "1.8"
    }
    buildFeatures {
        compose = true
    }
    composeOptions {
        kotlinCompilerExtensionVersion = "1.5.1"
    }

    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
            excludes += "META-INF/NOTICE.md"
            excludes += "META-INF/LICENSE.md"
            excludes += "META-INF/LICENSE.txt"
            excludes += "META-INF/NOTICE.txt"
        }
    }
}

dependencies {
    implementation(libs.msal)
    implementation(libs.volley)
    implementation(libs.graph)

    implementation(libs.sqlite)
    implementation(libs.androidx.lifecycle.viewmodel.compose)

    implementation(libs.androidx.material.icons.core)
    implementation(libs.androidx.material.icons.extended)

    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.androidx.activity.compose)
    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.ui)
    implementation(libs.androidx.ui.graphics)
    implementation(libs.androidx.ui.tooling.preview)
    implementation(libs.androidx.material3)
    implementation(libs.androidx.lifecycle.runtime.compose)
    implementation(libs.androidx.compose.runtime)
    testImplementation(libs.junit)
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)
    androidTestImplementation(platform(libs.androidx.compose.bom))
    androidTestImplementation(libs.androidx.ui.test.junit4)
    debugImplementation(libs.androidx.ui.tooling)
    debugImplementation(libs.androidx.ui.test.manifest)

}

// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\MainActivity.kt
package com.app.routineturboa

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import com.app.routineturboa.services.MSALAuthManager
import com.app.routineturboa.ui.MainScreen
import com.app.routineturboa.ui.theme.RoutineTurboATheme

class MainActivity : ComponentActivity() {
    private lateinit var msalAuthManager: MSALAuthManager

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Initialize MSALAuthManager
        msalAuthManager = MSALAuthManager(this)

        setContent {
            RoutineTurboATheme {
                Surface {
                    Column {
                        Greeting()
                        MainScreen()
                    }
                }
            }
        }
    }
}

@Composable
fun Greeting(){
    Text(text = "Routine", style = MaterialTheme.typography.headlineLarge)
}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\data\local\DatabaseHelper.kt
package com.app.routineturboa.data.local

import android.content.Context
import android.database.sqlite.SQLiteDatabase
import android.database.sqlite.SQLiteOpenHelper
import android.os.Environment
import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.io.IOException
import java.io.InputStream
import java.io.OutputStream

class DatabaseHelper(private val context: Context) : SQLiteOpenHelper(
    context, DATABASE_NAME, null, DATABASE_VERSION) {

    companion object {
        const val DATABASE_VERSION = 1
        const val DATABASE_NAME = "RoutineTurbo.db"
    }

    object DailyRoutine {
        const val TABLE_NAME = "daily_routine"
        const val COLUMN_NAME_ID = "id"
        const val COLUMN_NAME_START_TIME = "start_time"
        const val COLUMN_NAME_END_TIME = "end_time"
        const val COLUMN_NAME_DURATION = "duration"
        const val COLUMN_NAME_TASK_NAME = "task_name"
        const val COLUMN_NAME_REMINDERS = "reminders"
        const val COLUMN_NAME_TYPE = "type"
        const val COLUMN_NAME_POSITION = "position"
    }

    private val createEntries = """
        CREATE TABLE IF NOT EXISTS ${DailyRoutine.TABLE_NAME} (
            ${DailyRoutine.COLUMN_NAME_ID} INTEGER PRIMARY KEY AUTOINCREMENT,
            ${DailyRoutine.COLUMN_NAME_START_TIME} DATETIME,
            ${DailyRoutine.COLUMN_NAME_END_TIME} DATETIME,
            ${DailyRoutine.COLUMN_NAME_DURATION} INTEGER,
            ${DailyRoutine.COLUMN_NAME_TASK_NAME} TEXT,
            ${DailyRoutine.COLUMN_NAME_REMINDERS} DATETIME,
            ${DailyRoutine.COLUMN_NAME_TYPE} TEXT,
            ${DailyRoutine.COLUMN_NAME_POSITION} INTEGER)
    """

    private val deleteEntries = "DROP TABLE IF EXISTS ${DailyRoutine.TABLE_NAME}"

    override fun onCreate(db: SQLiteDatabase) {
        db.execSQL(createEntries)
    }

    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
        db.execSQL(deleteEntries)
        onCreate(db)
    }

    override fun getReadableDatabase(): SQLiteDatabase {
        copyDatabase()
        return super.getReadableDatabase()
    }

    override fun getWritableDatabase(): SQLiteDatabase {
        copyDatabase()
        return super.getWritableDatabase()
    }

    private fun copyDatabase() {
        val dbPath: String = context.getDatabasePath(DATABASE_NAME).absolutePath
        val dbFile = File(dbPath)
        if (!dbFile.exists()) {
            val externalDbPath = Environment.getExternalStorageDirectory().absolutePath + "/$DATABASE_NAME"
            val externalDbFile = File(externalDbPath)
            if (externalDbFile.exists()) {
                FileInputStream(externalDbFile).use { inputStream: InputStream ->
                    FileOutputStream(dbPath).use { outputStream: OutputStream ->
                        copyStream(inputStream, outputStream)
                    }
                }
            } else {
                context.assets.open(DATABASE_NAME).use { inputStream: InputStream ->
                    FileOutputStream(dbPath).use { outputStream: OutputStream ->
                        copyStream(inputStream, outputStream)
                    }
                }
            }
        }
    }

    @Throws(IOException::class)
    private fun copyStream(inputStream: InputStream, outputStream: OutputStream) {
        val buffer = ByteArray(1024)
        var length: Int
        while (inputStream.read(buffer).also { length = it } > 0) {
            outputStream.write(buffer, 0, length)
        }
    }
}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\data\local\RoutineRepository.kt
package com.app.routineturboa.data.local

import android.content.Context
import android.database.Cursor
import android.database.sqlite.SQLiteDatabase
import com.app.routineturboa.data.model.Task
import com.app.routineturboa.utils.TimeUtils

class RoutineRepository(context: Context) {
    private val dbHelper = DatabaseHelper(context)
    private val db: SQLiteDatabase = dbHelper.readableDatabase

    fun getAllTasks(): List<Task> {
        val tasks = mutableListOf<Task>()
        val cursor: Cursor = db.query(
            DatabaseHelper.DailyRoutine.TABLE_NAME,
            null,
            null,
            null,
            null,
            null,
            "${DatabaseHelper.DailyRoutine.COLUMN_NAME_POSITION} ASC"
        )
        with(cursor) {
            while (moveToNext()) {
                val startTime = getString(getColumnIndexOrThrow(DatabaseHelper.DailyRoutine.COLUMN_NAME_START_TIME))
                val endTime = getString(getColumnIndexOrThrow(DatabaseHelper.DailyRoutine.COLUMN_NAME_END_TIME))

                // Convert to 12-hour format
                val formattedStartTime = TimeUtils.convertTo12HourFormat(startTime.split(" ")[1])
                val formattedEndTime = TimeUtils.convertTo12HourFormat(endTime.split(" ")[1])

                val task = Task(
                    getInt(getColumnIndexOrThrow(DatabaseHelper.DailyRoutine.COLUMN_NAME_ID)),
                    formattedStartTime,
                    formattedEndTime,
                    getInt(getColumnIndexOrThrow(DatabaseHelper.DailyRoutine.COLUMN_NAME_DURATION)),
                    getString(getColumnIndexOrThrow(DatabaseHelper.DailyRoutine.COLUMN_NAME_TASK_NAME)),
                    getString(getColumnIndexOrThrow(DatabaseHelper.DailyRoutine.COLUMN_NAME_REMINDERS)),
                    getString(getColumnIndexOrThrow(DatabaseHelper.DailyRoutine.COLUMN_NAME_TYPE)),
                    getInt(getColumnIndexOrThrow(DatabaseHelper.DailyRoutine.COLUMN_NAME_POSITION))
                )
                tasks.add(task)
            }
        }
        cursor.close()
        return tasks
    }
}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\data\model\Task.kt
package com.app.routineturboa.data.model

data class Task(
    val id: Int,
    val startTime: String,
    val endTime: String,
    val duration: Int,
    val taskName: String,
    val reminders: String,
    val type: String,
    val position: Int
)


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\services\MSALAuthManager.kt
package com.app.routineturboa.services

import android.app.Activity
import android.content.Context
import android.util.Log
import com.app.routineturboa.R
import com.microsoft.identity.client.AuthenticationCallback
import com.microsoft.identity.client.IAccount
import com.microsoft.identity.client.IPublicClientApplication
import com.microsoft.identity.client.ISingleAccountPublicClientApplication
import com.microsoft.identity.client.PublicClientApplication
import com.microsoft.identity.client.exception.MsalException

class MSALAuthManager(context: Context) {

    private val appContext = context.applicationContext
    var singleAccountApp: ISingleAccountPublicClientApplication? = null

    init {
        PublicClientApplication.createSingleAccountPublicClientApplication(
            appContext,
            R.raw.auth_config_single_account,
            object : IPublicClientApplication.ISingleAccountApplicationCreatedListener {
                override fun onCreated(application: ISingleAccountPublicClientApplication) {
                    Log.d("MSALAuthManager", "MSAL client created")
                    singleAccountApp = application
                    checkCurrentAccount()
                }

                override fun onError(exception: MsalException) {
                    Log.e("MSALAuthManager", "MSAL client creation error: ${exception.message}")
                }
            })
    }

    private fun checkCurrentAccount() {
        singleAccountApp?.getCurrentAccountAsync(object : ISingleAccountPublicClientApplication.CurrentAccountCallback {
            override fun onAccountLoaded(activeAccount: IAccount?) {
                if (activeAccount != null) {
                    Log.d("MSALAuthManager", "An account is already signed in.")
                } else {
                    Log.d("MSALAuthManager", "No account is signed in.")
                }
            }

            override fun onAccountChanged(priorAccount: IAccount?, currentAccount: IAccount?) {
                // Handle account change if needed
            }

            override fun onError(exception: MsalException) {
                Log.e("MSALAuthManager", "Error loading current account: ${exception.message}")
            }
        })
    }

    fun signIn(activity: Activity, callback: AuthenticationCallback) {
        Log.d("MSALAuthManager", "Attempting to sign in")
        singleAccountApp?.signIn(activity, null, arrayOf("User.Read", "Files.Read"), callback)
            ?: Log.e("MSALAuthManager", "MSAL client is not initialized")
    }

    fun signOut(callback: ISingleAccountPublicClientApplication.SignOutCallback) {
        singleAccountApp?.signOut(callback)
    }
}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\services\OneDriveManager.kt
package com.app.routineturboa.services

import com.microsoft.graph.authentication.IAuthenticationProvider
import com.microsoft.graph.models.DriveItem
import com.microsoft.graph.requests.GraphServiceClient
import com.microsoft.identity.client.IAuthenticationResult
import java.io.File
import java.io.FileOutputStream
import java.net.URL
import java.util.concurrent.CompletableFuture

class OneDriveManager(private val authProvider: IAuthenticationProvider) {

    private val graphClient = GraphServiceClient.builder()
        .authenticationProvider(authProvider)
        .buildClient()

    fun listFiles(driveItemId: String? = null): List<DriveItem> {
        val request = if (driveItemId == null) {
            graphClient.me().drive().root().children().buildRequest()
        } else {
            graphClient.me().drive().items(driveItemId).children().buildRequest()
        }

        return request.get()?.currentPage ?: emptyList()
    }

    fun downloadFile(driveItemId: String, destinationFile: File): Boolean {
        val request = graphClient.me().drive().items(driveItemId).content().buildRequest()
        return try {
            val inputStream = request.get()
            if (inputStream != null) {
                FileOutputStream(destinationFile).use { outputStream ->
                    inputStream.copyTo(outputStream)
                }
                true
            } else {
                false
            }
        } catch (e: Exception) {
            e.printStackTrace()
            false
        }
    }


    class MsalAuthProvider(private val authenticationResult: IAuthenticationResult) : IAuthenticationProvider {
        override fun getAuthorizationTokenAsync(requestUrl: URL): CompletableFuture<String> {
            return CompletableFuture.completedFuture(authenticationResult.accessToken)
        }
    }
}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\ui\MainScreen.kt
package com.app.routineturboa.ui

import TaskViewModelFactory
import android.util.Log
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Button
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.app.routineturboa.MainActivity
import com.app.routineturboa.data.local.DatabaseHelper
import com.app.routineturboa.data.local.RoutineRepository
import com.app.routineturboa.services.MSALAuthManager
import com.app.routineturboa.services.OneDriveManager
import com.app.routineturboa.ui.components.TaskItem
import com.app.routineturboa.viewmodel.TaskViewModel
import com.microsoft.graph.models.DriveItem
import com.microsoft.identity.client.AuthenticationCallback
import com.microsoft.identity.client.IAccount
import com.microsoft.identity.client.IAuthenticationResult
import com.microsoft.identity.client.ISingleAccountPublicClientApplication
import com.microsoft.identity.client.exception.MsalException
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext


@Composable
fun MainScreen(taskViewModel: TaskViewModel = viewModel(factory = TaskViewModelFactory(RoutineRepository(LocalContext.current)
))) {

    val tasks by taskViewModel.tasks.collectAsState()
    val context = LocalContext.current
    val msalAuthManager = remember { MSALAuthManager(context) }
    var oneDriveFiles by remember { mutableStateOf<List<DriveItem>>(emptyList()) }
    var authenticationResult by remember { mutableStateOf<IAuthenticationResult?>(null) }
    val coroutineScope = rememberCoroutineScope()

    LaunchedEffect(authenticationResult) {
        authenticationResult?.let { authResult ->
            val authProvider = OneDriveManager.MsalAuthProvider(authResult)
            val oneDriveManager = OneDriveManager(authProvider)
            coroutineScope.launch {
                withContext(Dispatchers.IO) {
                    val files = oneDriveManager.listFiles() // List root directory files
                    val routineTurboDir = files.find { it.name == "RoutineTurbo" && it.folder != null }

                    routineTurboDir?.let { dir ->
                        val dirFiles = oneDriveManager.listFiles(dir.id) // List files in RoutineTurbo directory
                        oneDriveFiles = dirFiles
                        val dbFile = dirFiles.find { it.name == "RoutineTurbo.db" }
                        dbFile?.let { driveItem ->
                            driveItem.id?.let { driveItemId ->
                                val localDbFile = context.getDatabasePath(DatabaseHelper.DATABASE_NAME)
                                oneDriveManager.downloadFile(driveItemId, localDbFile)
                                taskViewModel.loadTasks()
                            }
                        }
                    }
                }
            }
        }
    }


    DisposableEffect(Unit) {
        Log.d("MainScreen", "Starting sign-in process")
        msalAuthManager.signIn(context as MainActivity, object : AuthenticationCallback {
            override fun onSuccess(result: IAuthenticationResult) {
                Log.d("MainScreen", "Sign-in successful")
                authenticationResult = result
            }

            override fun onError(exception: MsalException) {
                Log.e("MainScreen", "Sign-in error: ${exception.message}")
            }

            override fun onCancel() {
                Log.d("MainScreen", "Sign-in canceled")
            }
        })
        onDispose { }
    }

    Surface(
        modifier = Modifier.fillMaxSize(),
        color = MaterialTheme.colorScheme.background
    ) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            SignInButton(msalAuthManager, authenticationResult) { result ->
                authenticationResult = result
            }
            LazyColumn(
                contentPadding = PaddingValues(5.dp),
                verticalArrangement = Arrangement.spacedBy(3.dp)
            ) {
                items(tasks) { task ->
                    TaskItem(task)
                }
                items(oneDriveFiles) { file ->
                    Text(text = file.name ?: "No name")
                }
            }
        }
    }
}

@Composable
fun SignInButton(
    msalAuthManager: MSALAuthManager,
    authenticationResult: IAuthenticationResult?,
    onSignInSuccess: (IAuthenticationResult) -> Unit
) {
    val context = LocalContext.current
    var isSigningIn by remember { mutableStateOf(false) }

    Button(
        onClick = {
            Log.d("SignInButton", "Sign-in button clicked")
            isSigningIn = true

            // Check if an account is already signed in
            msalAuthManager.singleAccountApp?.getCurrentAccountAsync(object : ISingleAccountPublicClientApplication.CurrentAccountCallback {
                override fun onAccountLoaded(activeAccount: IAccount?) {
                    if (activeAccount != null) {
                        // An account is already signed in, sign out first
                        msalAuthManager.signOut(object : ISingleAccountPublicClientApplication.SignOutCallback {
                            override fun onSignOut() {
                                Log.d("SignInButton", "Signed out successfully, now signing in again.")
                                signIn(msalAuthManager, context as MainActivity, onSignInSuccess)
                            }

                            override fun onError(exception: MsalException) {
                                Log.e("SignInButton", "Sign-out error: ${exception.message}")
                                isSigningIn = false
                            }
                        })
                    } else {
                        // No account is signed in, proceed with sign-in
                        signIn(msalAuthManager, context as MainActivity, onSignInSuccess)
                    }
                }

                override fun onAccountChanged(priorAccount: IAccount?, currentAccount: IAccount?) {
                    // Handle account change if needed
                }

                override fun onError(exception: MsalException) {
                    Log.e("SignInButton", "Error loading current account: ${exception.message}")
                    isSigningIn = false
                }
            })
        },
        enabled = authenticationResult == null && !isSigningIn
    ) {
        Text(text = if (authenticationResult != null) "Signed In" else "Sign In")
    }
}

fun signIn(msalAuthManager: MSALAuthManager, activity: MainActivity, onSignInSuccess: (IAuthenticationResult) -> Unit) {
    msalAuthManager.signIn(activity, object : AuthenticationCallback {
        override fun onSuccess(result: IAuthenticationResult) {
            Log.d("SignInButton", "Sign-in successful")
            onSignInSuccess(result)
        }

        override fun onError(exception: MsalException) {
            Log.e("SignInButton", "Sign-in error: ${exception.message}")
        }

        override fun onCancel() {
            Log.d("SignInButton", "Sign-in canceled")
        }
    })
}


@Preview(showBackground = true)
@Composable
fun MainScreenPreview() {
    MainScreen()
}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\ui\components\TaskItem.kt
package com.app.routineturboa.ui.components

import androidx.compose.foundation.border
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Task
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import com.app.routineturboa.data.model.Task

@Composable
fun TaskItem(task: Task) {
    // Card to hold the task details
    Card(
        modifier = Modifier
            .padding(1.dp)
            .fillMaxWidth()
            .border(1.dp, MaterialTheme.colorScheme.outline, RoundedCornerShape(8.dp)), // Adding a border to the Card

        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.background
        ),

        elevation = CardDefaults.cardElevation(3.dp)  // Like shadow
    ) {

        // vertical layout container inside the Card
        Column(
            modifier = Modifier
                .padding(25.dp)
        ) {

            // Row for task name and icon
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically
            ) {

                // Task name
                Text(
                    text = task.taskName,
                    style = MaterialTheme.typography.titleLarge.copy(
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    ),
                    modifier = Modifier
                        .weight(3f),
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
                // Task icon
                Icon(
                    imageVector = Icons.Default.Task,
                    contentDescription = null,
                    tint = MaterialTheme.colorScheme.secondary
                )
            }

            // Spacer between task name and start time
            Spacer(modifier = Modifier.height(18.dp))

            // Row for start time and duration
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                // Start time
                Text(
                    text = "${task.startTime} - ${task.endTime}",
                    style = MaterialTheme.typography.bodyLarge.copy(
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                )


                // Duration
                Text(
                    text = "${task.duration} minutes",
                    style = MaterialTheme.typography.bodyLarge.copy(
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                )
            }
        }
    }
}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\ui\components\TaskItemComposable_simple.kt
package com.app.routineturboa.ui.components

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Task
import androidx.compose.material3.Card
import androidx.compose.material3.Icon
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import com.app.routineturboa.data.model.Task
import com.app.routineturboa.utils.TimeUtils.convertTo12HourFormat

@Composable
fun TaskItemComposable(task: Task) {
    Card{
        Column{
            Row{
                Text(text = task.taskName)
                Icon(imageVector = Icons.Default.Task,
                    contentDescription = null)
            }
            Row{
                Text(text = "${convertTo12HourFormat(task.startTime.split(" ")[1])} - ${convertTo12HourFormat(task.endTime.split(" ")[1])}")
                Text(text = "${task.duration} minutes")
            }
        }
    }
}



// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\ui\theme\Color.kt
package com.app.routineturboa.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)

// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\ui\theme\Theme.kt
package com.app.routineturboa.ui.theme

import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.graphics.Color


@Composable
fun RoutineTurboATheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable () -> Unit
) {
    val colorScheme = if (darkTheme) {
        darkColorScheme(
            primary = Color(0xFF6200EE),
            secondary = Color(0xFF03DAC6),
            background = Color(0xFF202B32),
            surfaceVariant = Color(0xFFB81818),
            outline = Color(0xFFDADADA)
        )
    } else {
        lightColorScheme(
            primary = Color(0xFF6200EE),
            secondary = Color(0xFF03DAC6),
            background = Color(0xFFF3F3F3),
            surfaceVariant = Color(0xFF5A0F0F),
            outline = Color(0xFF8B8B8B)

        )
    }

    MaterialTheme(
        colorScheme = colorScheme,
        content = content
    )
}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\ui\theme\Type.kt
package com.app.routineturboa.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// Set of Material typography styles to start with
val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 18.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    ),

    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 24.sp,
        lineHeight = 30.sp,
        letterSpacing = 0.sp
    ),

    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
)

// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\utils\TimeUtils.kt
package com.app.routineturboa.utils

import java.text.SimpleDateFormat
import java.util.Locale

object TimeUtils {
    fun convertTo12HourFormat(time: String): String {
        val inputFormat = SimpleDateFormat("HH:mm:ss", Locale.getDefault())
        val outputFormat = SimpleDateFormat("hh:mm a", Locale.getDefault())
        val date = inputFormat.parse(time)
        return outputFormat.format(date!!)
    }
}

// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\viewmodel\TaskViewModel.kt
package com.app.routineturboa.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.app.routineturboa.data.local.RoutineRepository
import com.app.routineturboa.data.model.Task
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

class TaskViewModel(private val repository: RoutineRepository) : ViewModel() {
    private val _tasks = MutableStateFlow<List<Task>>(emptyList())
    val tasks: StateFlow<List<Task>> = _tasks.asStateFlow()

    init {
        loadTasks()
    }

    fun loadTasks() {
        viewModelScope.launch(Dispatchers.IO) {
            val taskList = repository.getAllTasks()
            _tasks.value = taskList
        }
    }
}



// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\viewmodel\TaskViewModelFactory.kt
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import com.app.routineturboa.data.local.RoutineRepository
import com.app.routineturboa.viewmodel.TaskViewModel

class TaskViewModelFactory(private val repository: RoutineRepository) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(TaskViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return TaskViewModel(repository) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

