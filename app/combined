
// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\AndroidManifest.xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <application
        android:name=".MyApplication"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        tools:targetApi="31">
        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <!-- MSAL BrowserTabActivity configuration -->
        <activity
            android:name="com.microsoft.identity.client.BrowserTabActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />
                <data android:scheme="msauth"
                    android:host="com.app.routineturboa"
                    android:path="/a0VHP+Yc7DrhJPus83+LbjsqzHY=" />
            </intent-filter>
        </activity>

    </application>
</manifest>

// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\build.gradle.kts
plugins {
    alias(libs.plugins.androidApplication)
    alias(libs.plugins.jetbrainsKotlinAndroid)
    alias(libs.plugins.compose.compiler)
}

android {
    namespace = "com.app.routineturboa"
    compileSdk = 34

    defaultConfig {
        applicationId = "com.app.routineturboa"
        minSdk = 30
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
        versionNameSuffix = "1"
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
    kotlinOptions {
        jvmTarget = "1.8"
    }
    buildFeatures {
        compose = true
    }
    composeOptions {
        kotlinCompilerExtensionVersion = "1.5.1" // Ensure this version is compatible with Kotlin 1.9.0
    }

    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
            excludes += "META-INF/NOTICE.md"
            excludes += "META-INF/LICENSE.md"
            excludes += "META-INF/LICENSE.txt"
            excludes += "META-INF/NOTICE.txt"
        }
    }
}

dependencies {
    implementation(libs.coil.compose)

    implementation(libs.msal)
    implementation(libs.volley)
    implementation(libs.graph)

    implementation(libs.sqlite)
    implementation(libs.androidx.lifecycle.viewmodel.compose)

    implementation(libs.androidx.material.icons.core)
    implementation(libs.androidx.material.icons.extended)

    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.androidx.activity.compose)
    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.ui)
    implementation(libs.androidx.ui.graphics)
    implementation(libs.androidx.ui.tooling.preview)
    implementation(libs.androidx.material3)
    implementation(libs.androidx.lifecycle.runtime.compose)
    implementation(libs.androidx.compose.runtime)
    testImplementation(libs.junit)
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)
    androidTestImplementation(platform(libs.androidx.compose.bom))
    androidTestImplementation(libs.androidx.ui.test.junit4)
    debugImplementation(libs.androidx.ui.tooling)
    debugImplementation(libs.androidx.ui.test.manifest)

}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\MainActivity.kt
package com.app.routineturboa

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import com.app.routineturboa.services.MSALAuthManager
import com.app.routineturboa.ui.MainScreen
import com.app.routineturboa.ui.theme.RoutineTurboATheme

class MainActivity : ComponentActivity() {
    private lateinit var msalAuthManager: MSALAuthManager

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        msalAuthManager = MSALAuthManager.getInstance(this)

        setContent {
            RoutineTurboATheme {
                Surface {
                    Column {
                        Greeting()
                        MainScreen()
                    }
                }
            }
        }
    }
}

@Composable
fun Greeting(){
    Text(text = "Routine", style = MaterialTheme.typography.headlineLarge)
}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\MyApplication.kt
package com.app.routineturboa

import android.app.Application
import com.app.routineturboa.services.MSALAuthManager

class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        MSALAuthManager.getInstance(this)
    }
}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\data\local\DatabaseHelper.kt
package com.app.routineturboa.data.local

import android.content.Context
import android.database.sqlite.SQLiteDatabase
import android.database.sqlite.SQLiteOpenHelper
import android.os.Environment
import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.io.IOException
import java.io.InputStream
import java.io.OutputStream

class DatabaseHelper(private val context: Context) : SQLiteOpenHelper(
    context, DATABASE_NAME, null, DATABASE_VERSION) {

    companion object {
        const val DATABASE_VERSION = 1
        const val DATABASE_NAME = "RoutineTurbo.db"
    }

    object DailyRoutine {
        const val TABLE_NAME = "daily_routine"
        const val COLUMN_NAME_ID = "id"
        const val COLUMN_NAME_START_TIME = "start_time"
        const val COLUMN_NAME_END_TIME = "end_time"
        const val COLUMN_NAME_DURATION = "duration"
        const val COLUMN_NAME_TASK_NAME = "task_name"
        const val COLUMN_NAME_REMINDERS = "reminders"
        const val COLUMN_NAME_TYPE = "type"
        const val COLUMN_NAME_POSITION = "position"
    }

    private val createEntries = """
        CREATE TABLE IF NOT EXISTS ${DailyRoutine.TABLE_NAME} (
            ${DailyRoutine.COLUMN_NAME_ID} INTEGER PRIMARY KEY AUTOINCREMENT,
            ${DailyRoutine.COLUMN_NAME_START_TIME} DATETIME,
            ${DailyRoutine.COLUMN_NAME_END_TIME} DATETIME,
            ${DailyRoutine.COLUMN_NAME_DURATION} INTEGER,
            ${DailyRoutine.COLUMN_NAME_TASK_NAME} TEXT,
            ${DailyRoutine.COLUMN_NAME_REMINDERS} DATETIME,
            ${DailyRoutine.COLUMN_NAME_TYPE} TEXT,
            ${DailyRoutine.COLUMN_NAME_POSITION} INTEGER)
    """

    private val deleteEntries = "DROP TABLE IF EXISTS ${DailyRoutine.TABLE_NAME}"

    override fun onCreate(db: SQLiteDatabase) {
        db.execSQL(createEntries)
    }

    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
        db.execSQL(deleteEntries)
        onCreate(db)
    }

    override fun getReadableDatabase(): SQLiteDatabase {
        copyDatabase()
        return super.getReadableDatabase()
    }

    override fun getWritableDatabase(): SQLiteDatabase {
        copyDatabase()
        return super.getWritableDatabase()
    }

    private fun copyDatabase() {
        val dbPath: String = context.getDatabasePath(DATABASE_NAME).absolutePath
        val dbFile = File(dbPath)
        if (!dbFile.exists()) {
            val externalDbPath = Environment.getExternalStorageDirectory().absolutePath + "/$DATABASE_NAME"
            val externalDbFile = File(externalDbPath)
            if (externalDbFile.exists()) {
                FileInputStream(externalDbFile).use { inputStream: InputStream ->
                    FileOutputStream(dbPath).use { outputStream: OutputStream ->
                        copyStream(inputStream, outputStream)
                    }
                }
            } else {
                context.assets.open(DATABASE_NAME).use { inputStream: InputStream ->
                    FileOutputStream(dbPath).use { outputStream: OutputStream ->
                        copyStream(inputStream, outputStream)
                    }
                }
            }
        }
    }

    @Throws(IOException::class)
    private fun copyStream(inputStream: InputStream, outputStream: OutputStream) {
        val buffer = ByteArray(1024)
        var length: Int
        while (inputStream.read(buffer).also { length = it } > 0) {
            outputStream.write(buffer, 0, length)
        }
    }
}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\data\local\RoutineRepository.kt
package com.app.routineturboa.data.local

import android.content.ContentValues
import android.content.Context
import android.database.Cursor
import android.database.sqlite.SQLiteDatabase
import com.app.routineturboa.data.model.Task
import com.app.routineturboa.utils.TimeUtils
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class RoutineRepository(context: Context) {
    private val dbHelper = DatabaseHelper(context)
    private val db: SQLiteDatabase = dbHelper.readableDatabase

    suspend fun getAllTasks(): List<Task> = withContext(Dispatchers.IO) {
        val tasks = mutableListOf<Task>()
        val cursor: Cursor = db.query(
            DatabaseHelper.DailyRoutine.TABLE_NAME,
            arrayOf(
                DatabaseHelper.DailyRoutine.COLUMN_NAME_ID,
                DatabaseHelper.DailyRoutine.COLUMN_NAME_START_TIME,
                DatabaseHelper.DailyRoutine.COLUMN_NAME_END_TIME,
                DatabaseHelper.DailyRoutine.COLUMN_NAME_DURATION,
                DatabaseHelper.DailyRoutine.COLUMN_NAME_TASK_NAME,
                DatabaseHelper.DailyRoutine.COLUMN_NAME_REMINDERS,
                DatabaseHelper.DailyRoutine.COLUMN_NAME_TYPE,
                DatabaseHelper.DailyRoutine.COLUMN_NAME_POSITION
            ),
            null,
            null,
            null,
            null,
            "${DatabaseHelper.DailyRoutine.COLUMN_NAME_POSITION} ASC"
        )

        with(cursor) {
            while (moveToNext()) {
                val startTime = getString(getColumnIndexOrThrow(DatabaseHelper.DailyRoutine.COLUMN_NAME_START_TIME))
                val endTime = getString(getColumnIndexOrThrow(DatabaseHelper.DailyRoutine.COLUMN_NAME_END_TIME))

                val formattedStartTime = TimeUtils.convertTo12HourFormat(startTime)
                val formattedEndTime = TimeUtils.convertTo12HourFormat(endTime)

                val task = Task(
                    getInt(getColumnIndexOrThrow(DatabaseHelper.DailyRoutine.COLUMN_NAME_ID)),
                    formattedStartTime,
                    formattedEndTime,
                    getInt(getColumnIndexOrThrow(DatabaseHelper.DailyRoutine.COLUMN_NAME_DURATION)),
                    getString(getColumnIndexOrThrow(DatabaseHelper.DailyRoutine.COLUMN_NAME_TASK_NAME)),
                    getString(getColumnIndexOrThrow(DatabaseHelper.DailyRoutine.COLUMN_NAME_REMINDERS)),
                    getString(getColumnIndexOrThrow(DatabaseHelper.DailyRoutine.COLUMN_NAME_TYPE)),
                    getInt(getColumnIndexOrThrow(DatabaseHelper.DailyRoutine.COLUMN_NAME_POSITION))
                )
                tasks.add(task)
            }
        }
        cursor.close()
        return@withContext tasks
    }

    suspend fun updateTask(task: Task) = withContext(Dispatchers.IO) {
        val values = ContentValues().apply {
            val currentDate = "2024-01-01"  // Example, you should replace it with the actual date
            put(DatabaseHelper.DailyRoutine.COLUMN_NAME_START_TIME, TimeUtils.formatToDatabaseTime(currentDate, TimeUtils.convertTo24HourFormat(task.startTime)))
            put(DatabaseHelper.DailyRoutine.COLUMN_NAME_END_TIME, TimeUtils.formatToDatabaseTime(currentDate, TimeUtils.convertTo24HourFormat(task.endTime)))
            put(DatabaseHelper.DailyRoutine.COLUMN_NAME_DURATION, task.duration)
            put(DatabaseHelper.DailyRoutine.COLUMN_NAME_TASK_NAME, task.taskName)
            put(DatabaseHelper.DailyRoutine.COLUMN_NAME_REMINDERS, task.reminders)
            put(DatabaseHelper.DailyRoutine.COLUMN_NAME_TYPE, task.type)
            put(DatabaseHelper.DailyRoutine.COLUMN_NAME_POSITION, task.position)
        }
        val selection = "${DatabaseHelper.DailyRoutine.COLUMN_NAME_ID} = ?"
        val selectionArgs = arrayOf(task.id.toString())
        db.update(
            DatabaseHelper.DailyRoutine.TABLE_NAME,
            values,
            selection,
            selectionArgs
        )
    }
}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\data\model\Task.kt
package com.app.routineturboa.data.model

data class Task(
    val id: Int,
    val startTime: String,
    val endTime: String,
    val duration: Int,
    val taskName: String,
    val reminders: String,
    val type: String,
    val position: Int
)


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\services\MSALAuthManager.kt
package com.app.routineturboa.services

import android.app.Activity
import android.content.Context
import android.content.SharedPreferences
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.util.Log
import com.app.routineturboa.R
import com.microsoft.identity.client.AuthenticationCallback
import com.microsoft.identity.client.IAccount
import com.microsoft.identity.client.IAuthenticationResult
import com.microsoft.identity.client.IPublicClientApplication
import com.microsoft.identity.client.ISingleAccountPublicClientApplication
import com.microsoft.identity.client.PublicClientApplication
import com.microsoft.identity.client.exception.MsalException
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.OkHttpClient
import okhttp3.Request
import java.io.File
import java.io.FileOutputStream

class MSALAuthManager(context: Context) {

    private val appContext = context.applicationContext
    private val preferences: SharedPreferences = appContext.getSharedPreferences("msal_prefs", Context.MODE_PRIVATE)
    var singleAccountApp: ISingleAccountPublicClientApplication? = null
    var currentAccount: IAccount? = null

    init {
        PublicClientApplication.createSingleAccountPublicClientApplication(
            appContext,
            R.raw.auth_config_single_account,
            object : IPublicClientApplication.ISingleAccountApplicationCreatedListener {
                override fun onCreated(application: ISingleAccountPublicClientApplication) {
                    Log.d("MSALAuthManager", "MSAL client created")
                    singleAccountApp = application
                    checkCurrentAccount()
                }

                override fun onError(exception: MsalException) {
                    Log.e("MSALAuthManager", "MSAL client creation error: ${exception.message}")
                }
            })
    }

    private fun checkCurrentAccount() {
        singleAccountApp?.getCurrentAccountAsync(object : ISingleAccountPublicClientApplication.CurrentAccountCallback {
            override fun onAccountLoaded(activeAccount: IAccount?) {
                currentAccount = activeAccount
                if (activeAccount != null) {
                    Log.d("MSALAuthManager", "An account is already signed in.")
                    loadAuthResult() // Load authentication result from preferences
                } else {
                    Log.d("MSALAuthManager", "No account is signed in.")
                }
            }

            override fun onAccountChanged(priorAccount: IAccount?, currentAccount: IAccount?) {
                this@MSALAuthManager.currentAccount = currentAccount
            }

            override fun onError(exception: MsalException) {
                Log.e("MSALAuthManager", "Error loading current account: ${exception.message}")
            }
        })
    }

    companion object {
        @Volatile
        private var INSTANCE: MSALAuthManager? = null

        fun getInstance(context: Context): MSALAuthManager =
            INSTANCE ?: synchronized(this) {
                INSTANCE ?: MSALAuthManager(context).also { INSTANCE = it }
            }
    }

    fun signIn(activity: Activity, callback: AuthenticationCallback) {
        if (singleAccountApp != null) {
            Log.d("MSALAuthManager", "Attempting to sign in")
            singleAccountApp?.signIn(activity, null, arrayOf("User.Read", "Files.Read"), callback)
        } else {
            Log.e("MSALAuthManager", "MSAL client is not initialized")
        }
    }

    fun signOut(callback: ISingleAccountPublicClientApplication.SignOutCallback) {
        singleAccountApp?.signOut(callback)
        clearAuthResult() // Clear saved authentication result
    }

    suspend fun getProfileImageUrl(): String? {
        val account = currentAccount ?: return null
        return withContext(Dispatchers.IO) {
            try {
                val token = singleAccountApp?.acquireTokenSilent(arrayOf("User.Read"), account.authority)?.accessToken
                token?.let {
                    val client = OkHttpClient()
                    val request = Request.Builder()
                        .url("https://graph.microsoft.com/v1.0/me/photo/\$value")
                        .addHeader("Authorization", "Bearer $token")
                        .build()
                    val response = client.newCall(request).execute()
                    if (response.isSuccessful) {
                        val byteArray = response.body?.bytes()
                        byteArray?.let {
                            // Save the image as a file and return the file path or base64 string
                            val bitmap = BitmapFactory.decodeByteArray(byteArray, 0, byteArray.size)
                            val file = File(appContext.cacheDir, "profile_image.png")
                            FileOutputStream(file).use { out ->
                                bitmap.compress(Bitmap.CompressFormat.PNG, 100, out)
                            }
                            file.absolutePath
                        }
                    } else {
                        null
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
                null
            }
        }
    }

    fun saveAuthResult(authResult: IAuthenticationResult) {
        preferences.edit().putString("accessToken", authResult.accessToken).apply()
        preferences.edit().putString("idToken", authResult.account?.idToken).apply()
        preferences.edit().putString("accountName", authResult.account?.username).apply()
    }


    private fun loadAuthResult() {
        val accessToken = preferences.getString("accessToken", null)
        val idToken = preferences.getString("idToken", null)
        val accountName = preferences.getString("accountName", null)

        if (accessToken != null && idToken != null && accountName != null) {
            // Using stored information to set current account
            currentAccount = object : IAccount {
                override fun getId(): String = "storedId"
                override fun getUsername(): String = accountName
                override fun getAuthority(): String = "storedAuthority"
                override fun getClaims(): MutableMap<String, *>? = null
                override fun getIdToken(): String = idToken
                override fun getTenantId(): String = "storedTenantId" // Implementing the tenant ID method
            }
        }
    }

    private fun clearAuthResult() {
        preferences.edit().remove("accessToken").apply()
        preferences.edit().remove("idToken").apply()
        preferences.edit().remove("accountName").apply()
    }
}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\services\OneDriveManager.kt
package com.app.routineturboa.services

import com.microsoft.graph.authentication.IAuthenticationProvider
import com.microsoft.graph.models.DriveItem
import com.microsoft.graph.requests.GraphServiceClient
import com.microsoft.identity.client.IAuthenticationResult
import java.io.File
import java.io.FileOutputStream
import java.net.URL
import java.util.concurrent.CompletableFuture

class OneDriveManager(private val authProvider: IAuthenticationProvider) {

    private val graphClient = GraphServiceClient.builder()
        .authenticationProvider(authProvider)
        .buildClient()

    fun listFiles(driveItemId: String? = null): List<DriveItem> {
        val request = if (driveItemId == null) {
            graphClient.me().drive().root().children().buildRequest()
        } else {
            graphClient.me().drive().items(driveItemId).children().buildRequest()
        }

        return request.get()?.currentPage ?: emptyList()
    }

    fun downloadFile(driveItemId: String, destinationFile: File): Boolean {
        val request = graphClient.me().drive().items(driveItemId).content().buildRequest()
        return try {
            val inputStream = request.get()
            if (inputStream != null) {
                FileOutputStream(destinationFile).use { outputStream ->
                    inputStream.copyTo(outputStream)
                }
                true
            } else {
                false
            }
        } catch (e: Exception) {
            e.printStackTrace()
            false
        }
    }


    class MsalAuthProvider(private val authenticationResult: IAuthenticationResult) : IAuthenticationProvider {
        override fun getAuthorizationTokenAsync(requestUrl: URL): CompletableFuture<String> {
            return CompletableFuture.completedFuture(authenticationResult.accessToken)
        }
    }
}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\ui\MainScreen.kt
package com.app.routineturboa.ui

import TaskViewModelFactory
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.app.routineturboa.data.local.DatabaseHelper
import com.app.routineturboa.data.local.RoutineRepository
import com.app.routineturboa.data.model.Task
import com.app.routineturboa.services.MSALAuthManager
import com.app.routineturboa.services.OneDriveManager
import com.app.routineturboa.ui.components.EditTaskScreen
import com.app.routineturboa.ui.components.SignInButton
import com.app.routineturboa.ui.components.TaskItem
import com.app.routineturboa.viewmodel.TaskViewModel
import com.microsoft.graph.models.DriveItem
import com.microsoft.identity.client.IAuthenticationResult
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

@Composable
fun MainScreen(taskViewModel: TaskViewModel = viewModel(factory = TaskViewModelFactory(RoutineRepository(LocalContext.current)))) {
    val tasks by taskViewModel.tasks.collectAsState()
    var selectedTask by remember { mutableStateOf<Task?>(null) }
    val context = LocalContext.current
    val msalAuthManager = remember { MSALAuthManager.getInstance(context) }
    var oneDriveFiles by remember { mutableStateOf<List<DriveItem>>(emptyList()) }
    var authenticationResult by remember { mutableStateOf<IAuthenticationResult?>(null) }
    val coroutineScope = rememberCoroutineScope()

    LaunchedEffect(authenticationResult) {
        authenticationResult?.let { authResult ->
            val authProvider = OneDriveManager.MsalAuthProvider(authResult)
            val oneDriveManager = OneDriveManager(authProvider)
            coroutineScope.launch(Dispatchers.IO) {
                val files = oneDriveManager.listFiles()
                val routineTurboDir = files.find { it.name == "RoutineTurbo" && it.folder != null }
                routineTurboDir?.let { dir ->
                    val dirFiles = oneDriveManager.listFiles(dir.id)
                    oneDriveFiles = dirFiles
                    val dbFile = dirFiles.find { it.name == "RoutineTurbo.db" }
                    dbFile?.let { driveItem ->
                        driveItem.id?.let { driveItemId ->
                            val localDbFile = context.getDatabasePath(DatabaseHelper.DATABASE_NAME)
                            oneDriveManager.downloadFile(driveItemId, localDbFile)
                            withContext(Dispatchers.Main) {
                                taskViewModel.loadTasks()
                            }
                        }
                    }
                }
            }
        }
    }

    Surface(
        modifier = Modifier.fillMaxSize(),
        color = MaterialTheme.colorScheme.background
    ) {
        if (selectedTask == null) {
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                SignInButton(msalAuthManager, authenticationResult) { result ->
                    authenticationResult = result
                    msalAuthManager.saveAuthResult(result)
                }

                LazyColumn(
                    contentPadding = PaddingValues(5.dp),
                    verticalArrangement = Arrangement.spacedBy(3.dp)
                ) {
                    items(tasks, key = { it.id }) { task ->
                        TaskItem(task) {
                            selectedTask = it
                        }
                    }
                    items(oneDriveFiles, key = { it.id!! }) { file ->
                        Text(text = file.name ?: "No name")
                    }
                }
            }
        } else {
            EditTaskScreen(
                task = selectedTask!!,
                onSave = { updatedTask ->
                    taskViewModel.updateTask(updatedTask)
                    selectedTask = null
                },
                onCancel = {
                    selectedTask = null
                }
            )
        }
    }
}

@Preview(showBackground = true)
@Composable
fun MainScreenPreview() {
    MainScreen()
}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\ui\components\EditTaskScreen.kt
package com.app.routineturboa.ui.components

import android.widget.Toast
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.Button
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TextField
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import com.app.routineturboa.data.model.Task
import com.app.routineturboa.utils.TimeUtils
import java.text.ParseException

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EditTaskScreen(
    task: Task,
    onSave: (Task) -> Unit,
    onCancel: () -> Unit
) {
    var taskName by remember { mutableStateOf(task.taskName) }
    var startTime by remember { mutableStateOf(task.startTime) }
    var endTime by remember { mutableStateOf(task.endTime) }
    var duration by remember { mutableStateOf(task.duration.toString()) }

    val context = LocalContext.current

    Surface(
        modifier = Modifier.fillMaxWidth(),
        color = MaterialTheme.colorScheme.background,
        contentColor = MaterialTheme.colorScheme.onBackground
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            TextField(
                value = taskName,
                onValueChange = { taskName = it },
                label = { Text("Task Name") },
                modifier = Modifier.fillMaxWidth(),
                colors = TextFieldDefaults.textFieldColors(
                    containerColor = MaterialTheme.colorScheme.surface,
                    focusedIndicatorColor = MaterialTheme.colorScheme.primary,
                    unfocusedIndicatorColor = MaterialTheme.colorScheme.onSurface
                )
            )
            TextField(
                value = startTime,
                onValueChange = { startTime = it },
                label = { Text("Start Time (hh:mm a)") },
                modifier = Modifier.fillMaxWidth(),
                colors = TextFieldDefaults.textFieldColors(
                    containerColor = MaterialTheme.colorScheme.surface,
                    focusedIndicatorColor = MaterialTheme.colorScheme.primary,
                    unfocusedIndicatorColor = MaterialTheme.colorScheme.onSurface
                )
            )
            TextField(
                value = endTime,
                onValueChange = { endTime = it },
                label = { Text("End Time (hh:mm a)") },
                modifier = Modifier.fillMaxWidth(),
                colors = TextFieldDefaults.textFieldColors(
                    containerColor = MaterialTheme.colorScheme.surface,
                    focusedIndicatorColor = MaterialTheme.colorScheme.primary,
                    unfocusedIndicatorColor = MaterialTheme.colorScheme.onSurface
                )
            )
            TextField(
                value = duration,
                onValueChange = { duration = it },
                label = { Text("Duration") },
                keyboardOptions = KeyboardOptions.Default.copy(keyboardType = KeyboardType.Number),
                modifier = Modifier.fillMaxWidth(),
                colors = TextFieldDefaults.textFieldColors(
                    containerColor = MaterialTheme.colorScheme.surface,
                    focusedIndicatorColor = MaterialTheme.colorScheme.primary,
                    unfocusedIndicatorColor = MaterialTheme.colorScheme.onSurface
                )
            )
            Row(
                horizontalArrangement = Arrangement.SpaceBetween,
                modifier = Modifier.fillMaxWidth()
            ) {
                Button(onClick = { onCancel() }) {
                    Text("Cancel")
                }
                Button(onClick = {
                    if (TimeUtils.isValidTimeFormat(startTime) && TimeUtils.isValidTimeFormat(endTime)) {
                        try {
                            val updatedTask = task.copy(
                                taskName = taskName,
                                startTime = startTime,
                                endTime = endTime,
                                duration = duration.toInt()
                            )
                            onSave(updatedTask)
                        } catch (e: ParseException) {
                            Toast.makeText(context, "Invalid time format", Toast.LENGTH_SHORT).show()
                        }
                    } else {
                        Toast.makeText(context, "Please enter valid times in hh:mm a format", Toast.LENGTH_SHORT).show()
                    }
                }) {
                    Text("Save")
                }
            }
        }
    }
}



// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\ui\components\signInButton.kt
package com.app.routineturboa.ui.components

import android.util.Log
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.size
import androidx.compose.material3.Button
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import coil.compose.rememberAsyncImagePainter
import com.app.routineturboa.MainActivity
import com.app.routineturboa.services.MSALAuthManager
import com.microsoft.identity.client.AuthenticationCallback
import com.microsoft.identity.client.IAccount
import com.microsoft.identity.client.IAuthenticationResult
import com.microsoft.identity.client.ISingleAccountPublicClientApplication
import com.microsoft.identity.client.exception.MsalException
import kotlinx.coroutines.launch

@Composable
fun SignInButton(
    msalAuthManager: MSALAuthManager,
    authenticationResult: IAuthenticationResult?,
    onSignInSuccess: (IAuthenticationResult) -> Unit
) {
    val context = LocalContext.current
    val coroutineScope = rememberCoroutineScope()
    var isSigningIn by remember { mutableStateOf(false) }
    var profilePicUrl by remember { mutableStateOf<String?>(null) }
    var currentAuthResult by remember { mutableStateOf(authenticationResult) }

    // Fetch profile image URL when authentication result changes
    LaunchedEffect(currentAuthResult) {
        currentAuthResult?.let {
            coroutineScope.launch {
                profilePicUrl = msalAuthManager.getProfileImageUrl()
                Log.d("SignInButton", "Profile image URL fetched: $profilePicUrl")
            }
        }
    }

    Button(
        onClick = {
            Log.d("SignInButton", "Sign-in button clicked")
            isSigningIn = true
            msalAuthManager.singleAccountApp?.getCurrentAccountAsync(object : ISingleAccountPublicClientApplication.CurrentAccountCallback {
                override fun onAccountLoaded(activeAccount: IAccount?) {
                    if (activeAccount != null) {
                        msalAuthManager.signOut(object : ISingleAccountPublicClientApplication.SignOutCallback {
                            override fun onSignOut() {
                                Log.d("SignInButton", "Signed out successfully, now signing in again.")
                                signIn(msalAuthManager, context as MainActivity, onSignInSuccess)
                            }

                            override fun onError(exception: MsalException) {
                                Log.e("SignInButton", "Sign-out error: ${exception.message}")
                                isSigningIn = false
                            }
                        })
                    } else {
                        signIn(msalAuthManager, context as MainActivity, onSignInSuccess)
                    }
                }

                override fun onAccountChanged(priorAccount: IAccount?, currentAccount: IAccount?) {
                }

                override fun onError(exception: MsalException) {
                    Log.e("SignInButton", "Error loading current account: ${exception.message}")
                    isSigningIn = false
                }
            })
        },
        enabled = !isSigningIn // Disable button during sign-in process
    ) {
        Row {
            if (currentAuthResult != null && profilePicUrl != null) {
                Image(
                    painter = rememberAsyncImagePainter(profilePicUrl),
                    contentDescription = "Profile Picture",
                    modifier = Modifier.size(24.dp)
                )
                Text(text = "Signed In") // Show "Signed In" when signed in
            } else {
                Text(text = "Sign In") // Show "Sign In" when not signed in
            }
        }
    }
}

fun signIn(msalAuthManager: MSALAuthManager, activity: MainActivity, onSignInSuccess: (IAuthenticationResult) -> Unit) {
    msalAuthManager.signIn(activity, object : AuthenticationCallback {
        override fun onSuccess(result: IAuthenticationResult) {
            Log.d("SignInButton", "Sign-in successful")
            onSignInSuccess(result)
        }

        override fun onError(exception: MsalException) {
            Log.e("SignInButton", "Sign-in error: ${exception.message}")
        }

        override fun onCancel() {
            Log.d("SignInButton", "Sign-in canceled")
        }
    })
}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\ui\components\TaskItem.kt
package com.app.routineturboa.ui.components

import androidx.compose.foundation.border
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import com.app.routineturboa.data.model.Task

@Composable
fun TaskItem(task: Task, onEditClick: (Task) -> Unit) {
    Card(
        modifier = Modifier
            .padding(1.dp)
            .fillMaxWidth()
            .border(1.dp, MaterialTheme.colorScheme.outline, RoundedCornerShape(8.dp)),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.background
        ),
        elevation = CardDefaults.cardElevation(3.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = androidx.compose.ui.Alignment.CenterVertically
            ) {
                Text(
                    text = task.taskName,
                    style = MaterialTheme.typography.titleLarge.copy(
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    ),
                    modifier = Modifier.weight(3f),
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
                IconButton(onClick = { onEditClick(task) }) {
                    Icon(Icons.Default.Edit, contentDescription = "Edit Task")
                }
            }
            Spacer(modifier = Modifier.height(8.dp))
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = "${task.startTime} - ${task.endTime}",
                    style = MaterialTheme.typography.bodyLarge.copy(
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                )
                Text(
                    text = "${task.duration} minutes",
                    style = MaterialTheme.typography.bodyLarge.copy(
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                )
            }
        }
    }
}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\ui\components\TaskItemComposable_simple.kt
package com.app.routineturboa.ui.components

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Task
import androidx.compose.material3.Card
import androidx.compose.material3.Icon
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import com.app.routineturboa.data.model.Task
import com.app.routineturboa.utils.TimeUtils.convertTo12HourFormat

@Composable
fun TaskItemComposable(task: Task) {
    Card{
        Column{
            Row{
                Text(text = task.taskName)
                Icon(imageVector = Icons.Default.Task,
                    contentDescription = null)
            }
            Row{
                Text(text = "${convertTo12HourFormat(task.startTime.split(" ")[1])} - ${convertTo12HourFormat(task.endTime.split(" ")[1])}")
                Text(text = "${task.duration} minutes")
            }
        }
    }
}



// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\ui\theme\Color.kt
package com.app.routineturboa.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)

// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\ui\theme\Theme.kt
package com.app.routineturboa.ui.theme

import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.graphics.Color


@Composable
fun RoutineTurboATheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable () -> Unit
) {
    val colorScheme = if (darkTheme) {
        darkColorScheme(
            primary = Color(0xFF6200EE),
            secondary = Color(0xFF03DAC6),
            background = Color(0xFF202B32),
            surfaceVariant = Color(0xFFB81818),
            outline = Color(0xFFDADADA)
        )
    } else {
        lightColorScheme(
            primary = Color(0xFF6200EE),
            secondary = Color(0xFF03DAC6),
            background = Color(0xFFF3F3F3),
            surfaceVariant = Color(0xFF5A0F0F),
            outline = Color(0xFF8B8B8B)

        )
    }

    MaterialTheme(
        colorScheme = colorScheme,
        content = content
    )
}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\ui\theme\Type.kt
package com.app.routineturboa.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// Set of Material typography styles to start with
val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 18.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    ),

    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 24.sp,
        lineHeight = 30.sp,
        letterSpacing = 0.sp
    ),

    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
)

// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\utils\TimeUtils.kt
package com.app.routineturboa.utils

import java.text.ParseException
import java.text.SimpleDateFormat
import java.util.Locale

object TimeUtils {

    private val inputFormat: SimpleDateFormat
        get() = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())
    private val outputFormat: SimpleDateFormat
        get() = SimpleDateFormat("hh:mm a", Locale.getDefault())
    private val timeOnlyFormat: SimpleDateFormat
        get() = SimpleDateFormat("HH:mm:ss", Locale.getDefault())  // Ensure the time format includes seconds

    fun convertTo12HourFormat(time: String): String {
        val date = inputFormat.parse(time)
        return outputFormat.format(date!!)
    }

    fun convertTo24HourFormat(time: String): String {
        val date = outputFormat.parse(time)
        return timeOnlyFormat.format(date!!)
    }

    fun formatToDatabaseTime(date: String, time: String): String {
        val datetime = "$date $time:00"  // Append seconds to match "HH:mm:ss"
        val dateObj = inputFormat.parse(datetime)
        return inputFormat.format(dateObj!!)
    }

    fun isValidTimeFormat(time: String): Boolean {
        return try {
            outputFormat.parse(time)
            true
        } catch (e: ParseException) {
            false
        }
    }
}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\viewmodel\TaskViewModel.kt
package com.app.routineturboa.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.app.routineturboa.data.local.RoutineRepository
import com.app.routineturboa.data.model.Task
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

class TaskViewModel(private val repository: RoutineRepository) : ViewModel() {
    private val _tasks = MutableStateFlow<List<Task>>(emptyList())
    val tasks: StateFlow<List<Task>> = _tasks.asStateFlow()

    init {
        loadTasks()
    }

    fun loadTasks() {
        viewModelScope.launch {
            val taskList = repository.getAllTasks()
            _tasks.value = taskList
        }
    }

    fun updateTask(task: Task) {
        viewModelScope.launch {
            repository.updateTask(task)
            loadTasks()
        }
    }
}


// Content from C:\Users\Vivid\AndroidStudioProjects\RoutineTurbo_android\app\src\main\java\com\app\routineturboa\viewmodel\TaskViewModelFactory.kt
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import com.app.routineturboa.data.local.RoutineRepository
import com.app.routineturboa.viewmodel.TaskViewModel

class TaskViewModelFactory(private val repository: RoutineRepository) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(TaskViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return TaskViewModel(repository) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

